// Code generated by tags_gen.go; DO NOT EDIT.
package html

type HTMLElementState struct {
	AltKey      bool
	CtrlKey     bool
	ShiftKey    bool
	MetaKey     bool
	PointerType string
	PointerID   int
	Button      int
	Buttons     int
	ClientX     float64
	ClientY     float64
	MovementX   float64
	MovementY   float64
	OffsetX     float64
	OffsetY     float64
	PageX       float64
	PageY       float64
	ScreenX     float64
	ScreenY     float64
	IsPrimary   bool
	WheelDeltaX float64
	WheelDeltaY float64
	WheelDeltaZ float64
}

type HTMLKeyboardState struct {
	Key         string
	Code        string
	Location    int
	Repeat      bool
	IsComposing bool
}

type HTMLMediaState struct {
	CurrentTime  float64
	Duration     float64
	Paused       bool
	Muted        bool
	Volume       float64
	Seeking      bool
	Ended        bool
	PlaybackRate float64
	ReadyState   int
}

type HTMLAElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// AState returns the cached snapshot for the <a> element ref.
func (ref *ElementRef[HTMLAElement]) AState() HTMLAElementState {
	if ref == nil {
		return HTMLAElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLAElementState); ok {
		return raw
	}
	return HTMLAElementState{}
}

func (ref *ElementRef[HTMLAElement]) dispatchHTMLAElementEvent(event string, snapshot HTMLAElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLAElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLAElementState(prev HTMLAElementState, payload map[string]any) HTMLAElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLAElementDefaults(ref *ElementRef[HTMLAElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AState()
			next := buildHTMLAElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLAElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementFocus(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLAElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementBlur(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLAElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementClick(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLAElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementDoubleClick(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLAElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementContextMenu(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLAElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementPointerDown(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLAElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementPointerUp(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLAElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementPointerMove(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLAElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementPointerEnter(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLAElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementPointerLeave(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLAElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementPointerOver(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLAElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementPointerOut(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLAElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementPointerCancel(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLAElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementWheel(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLAElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementKeyDown(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLAElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementKeyUp(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLAElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLAElement]) OnHTMLAElementKeyPress(handler func(HTMLAElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLAbbrElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// AbbrState returns the cached snapshot for the <abbr> element ref.
func (ref *ElementRef[HTMLAbbrElement]) AbbrState() HTMLAbbrElementState {
	if ref == nil {
		return HTMLAbbrElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLAbbrElementState); ok {
		return raw
	}
	return HTMLAbbrElementState{}
}

func (ref *ElementRef[HTMLAbbrElement]) dispatchHTMLAbbrElementEvent(event string, snapshot HTMLAbbrElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLAbbrElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLAbbrElementState(prev HTMLAbbrElementState, payload map[string]any) HTMLAbbrElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLAbbrElementDefaults(ref *ElementRef[HTMLAbbrElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AbbrState()
			next := buildHTMLAbbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAbbrElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLAbbrElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementFocus(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLAbbrElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementBlur(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLAbbrElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementClick(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLAbbrElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementDoubleClick(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLAbbrElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementContextMenu(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLAbbrElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementPointerDown(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLAbbrElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementPointerUp(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLAbbrElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementPointerMove(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLAbbrElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementPointerEnter(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLAbbrElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementPointerLeave(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLAbbrElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementPointerOver(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLAbbrElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementPointerOut(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLAbbrElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementPointerCancel(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLAbbrElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementWheel(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLAbbrElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementKeyDown(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLAbbrElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementKeyUp(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLAbbrElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLAbbrElement]) OnHTMLAbbrElementKeyPress(handler func(HTMLAbbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLAddressElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// AddressState returns the cached snapshot for the <address> element ref.
func (ref *ElementRef[HTMLAddressElement]) AddressState() HTMLAddressElementState {
	if ref == nil {
		return HTMLAddressElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLAddressElementState); ok {
		return raw
	}
	return HTMLAddressElementState{}
}

func (ref *ElementRef[HTMLAddressElement]) dispatchHTMLAddressElementEvent(event string, snapshot HTMLAddressElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLAddressElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLAddressElementState(prev HTMLAddressElementState, payload map[string]any) HTMLAddressElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLAddressElementDefaults(ref *ElementRef[HTMLAddressElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AddressState()
			next := buildHTMLAddressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAddressElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLAddressElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementFocus(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLAddressElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementBlur(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLAddressElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementClick(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLAddressElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementDoubleClick(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLAddressElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementContextMenu(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLAddressElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementPointerDown(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLAddressElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementPointerUp(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLAddressElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementPointerMove(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLAddressElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementPointerEnter(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLAddressElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementPointerLeave(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLAddressElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementPointerOver(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLAddressElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementPointerOut(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLAddressElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementPointerCancel(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLAddressElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementWheel(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLAddressElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementKeyDown(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLAddressElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementKeyUp(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLAddressElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLAddressElement]) OnHTMLAddressElementKeyPress(handler func(HTMLAddressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLAreaElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// AreaState returns the cached snapshot for the <area> element ref.
func (ref *ElementRef[HTMLAreaElement]) AreaState() HTMLAreaElementState {
	if ref == nil {
		return HTMLAreaElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLAreaElementState); ok {
		return raw
	}
	return HTMLAreaElementState{}
}

func (ref *ElementRef[HTMLAreaElement]) dispatchHTMLAreaElementEvent(event string, snapshot HTMLAreaElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLAreaElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLAreaElementState(prev HTMLAreaElementState, payload map[string]any) HTMLAreaElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLAreaElementDefaults(ref *ElementRef[HTMLAreaElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AreaState()
			next := buildHTMLAreaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAreaElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLAreaElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementFocus(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLAreaElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementBlur(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLAreaElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementClick(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLAreaElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementDoubleClick(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLAreaElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementContextMenu(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLAreaElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementPointerDown(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLAreaElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementPointerUp(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLAreaElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementPointerMove(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLAreaElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementPointerEnter(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLAreaElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementPointerLeave(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLAreaElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementPointerOver(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLAreaElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementPointerOut(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLAreaElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementPointerCancel(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLAreaElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementWheel(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLAreaElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementKeyDown(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLAreaElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementKeyUp(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLAreaElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLAreaElement]) OnHTMLAreaElementKeyPress(handler func(HTMLAreaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLArticleElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// ArticleState returns the cached snapshot for the <article> element ref.
func (ref *ElementRef[HTMLArticleElement]) ArticleState() HTMLArticleElementState {
	if ref == nil {
		return HTMLArticleElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLArticleElementState); ok {
		return raw
	}
	return HTMLArticleElementState{}
}

func (ref *ElementRef[HTMLArticleElement]) dispatchHTMLArticleElementEvent(event string, snapshot HTMLArticleElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLArticleElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLArticleElementState(prev HTMLArticleElementState, payload map[string]any) HTMLArticleElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLArticleElementDefaults(ref *ElementRef[HTMLArticleElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ArticleState()
			next := buildHTMLArticleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLArticleElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLArticleElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementFocus(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLArticleElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementBlur(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLArticleElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementClick(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLArticleElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementDoubleClick(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLArticleElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementContextMenu(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLArticleElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementPointerDown(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLArticleElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementPointerUp(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLArticleElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementPointerMove(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLArticleElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementPointerEnter(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLArticleElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementPointerLeave(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLArticleElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementPointerOver(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLArticleElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementPointerOut(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLArticleElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementPointerCancel(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLArticleElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementWheel(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLArticleElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementKeyDown(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLArticleElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementKeyUp(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLArticleElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLArticleElement]) OnHTMLArticleElementKeyPress(handler func(HTMLArticleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLAsideElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// AsideState returns the cached snapshot for the <aside> element ref.
func (ref *ElementRef[HTMLAsideElement]) AsideState() HTMLAsideElementState {
	if ref == nil {
		return HTMLAsideElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLAsideElementState); ok {
		return raw
	}
	return HTMLAsideElementState{}
}

func (ref *ElementRef[HTMLAsideElement]) dispatchHTMLAsideElementEvent(event string, snapshot HTMLAsideElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLAsideElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLAsideElementState(prev HTMLAsideElementState, payload map[string]any) HTMLAsideElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLAsideElementDefaults(ref *ElementRef[HTMLAsideElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AsideState()
			next := buildHTMLAsideElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAsideElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLAsideElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementFocus(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLAsideElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementBlur(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLAsideElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementClick(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLAsideElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementDoubleClick(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLAsideElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementContextMenu(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLAsideElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementPointerDown(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLAsideElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementPointerUp(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLAsideElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementPointerMove(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLAsideElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementPointerEnter(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLAsideElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementPointerLeave(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLAsideElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementPointerOver(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLAsideElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementPointerOut(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLAsideElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementPointerCancel(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLAsideElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementWheel(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLAsideElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementKeyDown(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLAsideElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementKeyUp(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLAsideElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLAsideElement]) OnHTMLAsideElementKeyPress(handler func(HTMLAsideElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLAudioElementState struct {
	HTMLMediaState
	HTMLElementState
	HTMLKeyboardState
}

// AudioState returns the cached snapshot for the <audio> element ref.
func (ref *ElementRef[HTMLAudioElement]) AudioState() HTMLAudioElementState {
	if ref == nil {
		return HTMLAudioElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLAudioElementState); ok {
		return raw
	}
	return HTMLAudioElementState{}
}

func (ref *ElementRef[HTMLAudioElement]) dispatchHTMLAudioElementEvent(event string, snapshot HTMLAudioElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLAudioElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLAudioElementState(prev HTMLAudioElementState, payload map[string]any) HTMLAudioElementState {
	next := prev
	next.CurrentTime = payloadFloat(payload, "target.currentTime", prev.CurrentTime)
	next.Duration = payloadFloat(payload, "target.duration", prev.Duration)
	next.Paused = payloadBool(payload, "target.paused", prev.Paused)
	next.Muted = payloadBool(payload, "target.muted", prev.Muted)
	next.Volume = payloadFloat(payload, "target.volume", prev.Volume)
	next.Seeking = payloadBool(payload, "target.seeking", prev.Seeking)
	next.Ended = payloadBool(payload, "target.ended", prev.Ended)
	next.PlaybackRate = payloadFloat(payload, "target.playbackRate", prev.PlaybackRate)
	next.ReadyState = payloadInt(payload, "target.readyState", prev.ReadyState)
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLAudioElementDefaults(ref *ElementRef[HTMLAudioElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("timeupdate", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("timeupdate"), EventOptions{
			Listen: []string{"durationchange", "play", "pause", "seeking", "seeked"},
			Props:  []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "timeupdate")
		ref.Bind("timeupdate", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("play", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("play"), EventOptions{
			Listen: []string{"playing"},
			Props:  []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "play")
		ref.Bind("play", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("pause", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pause"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pause")
		ref.Bind("pause", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("ended", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("ended"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "ended")
		ref.Bind("ended", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("volumechange", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("volumechange"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "volumechange")
		ref.Bind("volumechange", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("seeking", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("seeking"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "seeking")
		ref.Bind("seeking", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("seeked", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("seeked"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "seeked")
		ref.Bind("seeked", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("ratechange", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("ratechange"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "ratechange")
		ref.Bind("ratechange", binding)
	}
}

// OnHTMLAudioElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementFocus(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLAudioElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementBlur(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLAudioElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementClick(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLAudioElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementDoubleClick(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLAudioElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementContextMenu(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLAudioElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementPointerDown(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLAudioElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementPointerUp(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLAudioElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementPointerMove(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLAudioElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementPointerEnter(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLAudioElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementPointerLeave(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLAudioElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementPointerOver(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLAudioElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementPointerOut(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLAudioElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementPointerCancel(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLAudioElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementWheel(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLAudioElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementKeyDown(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLAudioElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementKeyUp(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLAudioElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLAudioElement]) OnHTMLAudioElementKeyPress(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnAudioTimeUpdate registers a handler for the "timeupdate" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioTimeUpdate(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("timeupdate", handler)
}

// OnAudioPlay registers a handler for the "play" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioPlay(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("play", handler)
}

// OnAudioPause registers a handler for the "pause" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioPause(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pause", handler)
}

// OnAudioEnded registers a handler for the "ended" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioEnded(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("ended", handler)
}

// OnAudioVolumeChange registers a handler for the "volumechange" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioVolumeChange(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("volumechange", handler)
}

// OnAudioSeeking registers a handler for the "seeking" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioSeeking(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("seeking", handler)
}

// OnAudioSeeked registers a handler for the "seeked" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioSeeked(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("seeked", handler)
}

// OnAudioRateChange registers a handler for the "ratechange" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioRateChange(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("ratechange", handler)
}

type HTMLBElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// BState returns the cached snapshot for the <b> element ref.
func (ref *ElementRef[HTMLBElement]) BState() HTMLBElementState {
	if ref == nil {
		return HTMLBElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLBElementState); ok {
		return raw
	}
	return HTMLBElementState{}
}

func (ref *ElementRef[HTMLBElement]) dispatchHTMLBElementEvent(event string, snapshot HTMLBElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLBElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLBElementState(prev HTMLBElementState, payload map[string]any) HTMLBElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLBElementDefaults(ref *ElementRef[HTMLBElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BState()
			next := buildHTMLBElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLBElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementFocus(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLBElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementBlur(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLBElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementClick(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLBElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementDoubleClick(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLBElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementContextMenu(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLBElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementPointerDown(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLBElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementPointerUp(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLBElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementPointerMove(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLBElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementPointerEnter(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLBElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementPointerLeave(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLBElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementPointerOver(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLBElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementPointerOut(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLBElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementPointerCancel(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLBElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementWheel(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLBElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementKeyDown(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLBElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementKeyUp(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLBElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLBElement]) OnHTMLBElementKeyPress(handler func(HTMLBElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLBaseElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// BaseState returns the cached snapshot for the <base> element ref.
func (ref *ElementRef[HTMLBaseElement]) BaseState() HTMLBaseElementState {
	if ref == nil {
		return HTMLBaseElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLBaseElementState); ok {
		return raw
	}
	return HTMLBaseElementState{}
}

func (ref *ElementRef[HTMLBaseElement]) dispatchHTMLBaseElementEvent(event string, snapshot HTMLBaseElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLBaseElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLBaseElementState(prev HTMLBaseElementState, payload map[string]any) HTMLBaseElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLBaseElementDefaults(ref *ElementRef[HTMLBaseElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BaseState()
			next := buildHTMLBaseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBaseElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLBaseElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementFocus(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLBaseElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementBlur(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLBaseElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementClick(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLBaseElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementDoubleClick(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLBaseElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementContextMenu(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLBaseElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementPointerDown(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLBaseElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementPointerUp(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLBaseElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementPointerMove(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLBaseElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementPointerEnter(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLBaseElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementPointerLeave(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLBaseElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementPointerOver(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLBaseElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementPointerOut(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLBaseElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementPointerCancel(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLBaseElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementWheel(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLBaseElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementKeyDown(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLBaseElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementKeyUp(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLBaseElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLBaseElement]) OnHTMLBaseElementKeyPress(handler func(HTMLBaseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLBdiElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// BdiState returns the cached snapshot for the <bdi> element ref.
func (ref *ElementRef[HTMLBdiElement]) BdiState() HTMLBdiElementState {
	if ref == nil {
		return HTMLBdiElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLBdiElementState); ok {
		return raw
	}
	return HTMLBdiElementState{}
}

func (ref *ElementRef[HTMLBdiElement]) dispatchHTMLBdiElementEvent(event string, snapshot HTMLBdiElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLBdiElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLBdiElementState(prev HTMLBdiElementState, payload map[string]any) HTMLBdiElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLBdiElementDefaults(ref *ElementRef[HTMLBdiElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdiState()
			next := buildHTMLBdiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdiElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLBdiElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementFocus(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLBdiElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementBlur(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLBdiElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementClick(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLBdiElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementDoubleClick(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLBdiElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementContextMenu(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLBdiElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementPointerDown(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLBdiElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementPointerUp(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLBdiElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementPointerMove(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLBdiElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementPointerEnter(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLBdiElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementPointerLeave(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLBdiElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementPointerOver(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLBdiElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementPointerOut(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLBdiElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementPointerCancel(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLBdiElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementWheel(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLBdiElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementKeyDown(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLBdiElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementKeyUp(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLBdiElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLBdiElement]) OnHTMLBdiElementKeyPress(handler func(HTMLBdiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLBdoElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// BdoState returns the cached snapshot for the <bdo> element ref.
func (ref *ElementRef[HTMLBdoElement]) BdoState() HTMLBdoElementState {
	if ref == nil {
		return HTMLBdoElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLBdoElementState); ok {
		return raw
	}
	return HTMLBdoElementState{}
}

func (ref *ElementRef[HTMLBdoElement]) dispatchHTMLBdoElementEvent(event string, snapshot HTMLBdoElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLBdoElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLBdoElementState(prev HTMLBdoElementState, payload map[string]any) HTMLBdoElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLBdoElementDefaults(ref *ElementRef[HTMLBdoElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BdoState()
			next := buildHTMLBdoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBdoElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLBdoElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementFocus(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLBdoElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementBlur(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLBdoElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementClick(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLBdoElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementDoubleClick(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLBdoElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementContextMenu(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLBdoElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementPointerDown(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLBdoElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementPointerUp(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLBdoElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementPointerMove(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLBdoElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementPointerEnter(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLBdoElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementPointerLeave(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLBdoElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementPointerOver(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLBdoElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementPointerOut(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLBdoElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementPointerCancel(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLBdoElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementWheel(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLBdoElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementKeyDown(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLBdoElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementKeyUp(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLBdoElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLBdoElement]) OnHTMLBdoElementKeyPress(handler func(HTMLBdoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLBlockquoteElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// BlockquoteState returns the cached snapshot for the <blockquote> element ref.
func (ref *ElementRef[HTMLBlockquoteElement]) BlockquoteState() HTMLBlockquoteElementState {
	if ref == nil {
		return HTMLBlockquoteElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLBlockquoteElementState); ok {
		return raw
	}
	return HTMLBlockquoteElementState{}
}

func (ref *ElementRef[HTMLBlockquoteElement]) dispatchHTMLBlockquoteElementEvent(event string, snapshot HTMLBlockquoteElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLBlockquoteElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLBlockquoteElementState(prev HTMLBlockquoteElementState, payload map[string]any) HTMLBlockquoteElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLBlockquoteElementDefaults(ref *ElementRef[HTMLBlockquoteElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BlockquoteState()
			next := buildHTMLBlockquoteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBlockquoteElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLBlockquoteElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementFocus(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLBlockquoteElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementBlur(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLBlockquoteElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementClick(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLBlockquoteElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementDoubleClick(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLBlockquoteElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementContextMenu(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLBlockquoteElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementPointerDown(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLBlockquoteElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementPointerUp(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLBlockquoteElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementPointerMove(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLBlockquoteElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementPointerEnter(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLBlockquoteElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementPointerLeave(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLBlockquoteElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementPointerOver(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLBlockquoteElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementPointerOut(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLBlockquoteElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementPointerCancel(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLBlockquoteElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementWheel(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLBlockquoteElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementKeyDown(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLBlockquoteElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementKeyUp(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLBlockquoteElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLBlockquoteElement]) OnHTMLBlockquoteElementKeyPress(handler func(HTMLBlockquoteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLBodyElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// BodyState returns the cached snapshot for the <body> element ref.
func (ref *ElementRef[HTMLBodyElement]) BodyState() HTMLBodyElementState {
	if ref == nil {
		return HTMLBodyElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLBodyElementState); ok {
		return raw
	}
	return HTMLBodyElementState{}
}

func (ref *ElementRef[HTMLBodyElement]) dispatchHTMLBodyElementEvent(event string, snapshot HTMLBodyElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLBodyElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLBodyElementState(prev HTMLBodyElementState, payload map[string]any) HTMLBodyElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLBodyElementDefaults(ref *ElementRef[HTMLBodyElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BodyState()
			next := buildHTMLBodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBodyElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLBodyElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementFocus(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLBodyElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementBlur(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLBodyElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementClick(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLBodyElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementDoubleClick(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLBodyElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementContextMenu(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLBodyElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementPointerDown(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLBodyElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementPointerUp(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLBodyElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementPointerMove(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLBodyElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementPointerEnter(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLBodyElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementPointerLeave(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLBodyElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementPointerOver(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLBodyElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementPointerOut(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLBodyElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementPointerCancel(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLBodyElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementWheel(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLBodyElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementKeyDown(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLBodyElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementKeyUp(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLBodyElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLBodyElement]) OnHTMLBodyElementKeyPress(handler func(HTMLBodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLBrElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// BrState returns the cached snapshot for the <br> element ref.
func (ref *ElementRef[HTMLBrElement]) BrState() HTMLBrElementState {
	if ref == nil {
		return HTMLBrElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLBrElementState); ok {
		return raw
	}
	return HTMLBrElementState{}
}

func (ref *ElementRef[HTMLBrElement]) dispatchHTMLBrElementEvent(event string, snapshot HTMLBrElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLBrElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLBrElementState(prev HTMLBrElementState, payload map[string]any) HTMLBrElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLBrElementDefaults(ref *ElementRef[HTMLBrElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.BrState()
			next := buildHTMLBrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLBrElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLBrElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementFocus(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLBrElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementBlur(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLBrElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementClick(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLBrElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementDoubleClick(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLBrElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementContextMenu(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLBrElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementPointerDown(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLBrElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementPointerUp(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLBrElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementPointerMove(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLBrElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementPointerEnter(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLBrElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementPointerLeave(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLBrElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementPointerOver(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLBrElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementPointerOut(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLBrElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementPointerCancel(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLBrElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementWheel(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLBrElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementKeyDown(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLBrElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementKeyUp(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLBrElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLBrElement]) OnHTMLBrElementKeyPress(handler func(HTMLBrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLButtonElementState struct {
	HTMLElementState
	HTMLKeyboardState
	Disabled   bool
	Type       string
	Value      string
	Name       string
	FormAction string
	FormMethod string
}

// ButtonState returns the cached snapshot for the <button> element ref.
func (ref *ElementRef[HTMLButtonElement]) ButtonState() HTMLButtonElementState {
	if ref == nil {
		return HTMLButtonElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLButtonElementState); ok {
		return raw
	}
	return HTMLButtonElementState{}
}

func (ref *ElementRef[HTMLButtonElement]) dispatchHTMLButtonElementEvent(event string, snapshot HTMLButtonElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLButtonElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLButtonElementState(prev HTMLButtonElementState, payload map[string]any) HTMLButtonElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	next.Disabled = payloadBool(payload, "target.disabled", prev.Disabled)
	next.Type = payloadString(payload, "target.type", prev.Type)
	next.Value = payloadString(payload, "target.value", prev.Value)
	next.Name = payloadString(payload, "target.name", prev.Name)
	next.FormAction = payloadString(payload, "target.formAction", prev.FormAction)
	next.FormMethod = payloadString(payload, "target.formMethod", prev.FormMethod)
	return next
}

func applyHTMLButtonElementDefaults(ref *ElementRef[HTMLButtonElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLButtonElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementFocus(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLButtonElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementBlur(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLButtonElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementClick(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLButtonElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementDoubleClick(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLButtonElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementContextMenu(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLButtonElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementPointerDown(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLButtonElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementPointerUp(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLButtonElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementPointerMove(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLButtonElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementPointerEnter(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLButtonElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementPointerLeave(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLButtonElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementPointerOver(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLButtonElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementPointerOut(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLButtonElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementPointerCancel(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLButtonElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementWheel(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLButtonElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementKeyDown(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLButtonElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementKeyUp(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLButtonElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLButtonElement]) OnHTMLButtonElementKeyPress(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnButtonClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLButtonElement]) OnButtonClick(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnButtonFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLButtonElement]) OnButtonFocus(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnButtonBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLButtonElement]) OnButtonBlur(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

type HTMLCanvasElementState struct {
	HTMLElementState
	HTMLKeyboardState
	Pressure           float64
	TangentialPressure float64
	TiltX              float64
	TiltY              float64
}

// CanvasState returns the cached snapshot for the <canvas> element ref.
func (ref *ElementRef[HTMLCanvasElement]) CanvasState() HTMLCanvasElementState {
	if ref == nil {
		return HTMLCanvasElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLCanvasElementState); ok {
		return raw
	}
	return HTMLCanvasElementState{}
}

func (ref *ElementRef[HTMLCanvasElement]) dispatchHTMLCanvasElementEvent(event string, snapshot HTMLCanvasElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLCanvasElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLCanvasElementState(prev HTMLCanvasElementState, payload map[string]any) HTMLCanvasElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	next.Pressure = payloadFloat(payload, "event.pressure", prev.Pressure)
	next.TangentialPressure = payloadFloat(payload, "event.tangentialPressure", prev.TangentialPressure)
	next.TiltX = payloadFloat(payload, "event.tiltX", prev.TiltX)
	next.TiltY = payloadFloat(payload, "event.tiltY", prev.TiltY)
	return next
}

func applyHTMLCanvasElementDefaults(ref *ElementRef[HTMLCanvasElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLCanvasElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementFocus(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLCanvasElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementBlur(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLCanvasElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementClick(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLCanvasElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementDoubleClick(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLCanvasElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementContextMenu(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLCanvasElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementPointerDown(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLCanvasElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementPointerUp(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLCanvasElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementPointerMove(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLCanvasElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementPointerEnter(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLCanvasElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementPointerLeave(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLCanvasElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementPointerOver(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLCanvasElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementPointerOut(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLCanvasElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementPointerCancel(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLCanvasElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementWheel(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLCanvasElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementKeyDown(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLCanvasElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementKeyUp(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLCanvasElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLCanvasElement]) OnHTMLCanvasElementKeyPress(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnCanvasPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLCanvasElement]) OnCanvasPointerMove(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnCanvasPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLCanvasElement]) OnCanvasPointerDown(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnCanvasPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLCanvasElement]) OnCanvasPointerUp(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnCanvasWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLCanvasElement]) OnCanvasWheel(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

type HTMLCaptionElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// CaptionState returns the cached snapshot for the <caption> element ref.
func (ref *ElementRef[HTMLCaptionElement]) CaptionState() HTMLCaptionElementState {
	if ref == nil {
		return HTMLCaptionElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLCaptionElementState); ok {
		return raw
	}
	return HTMLCaptionElementState{}
}

func (ref *ElementRef[HTMLCaptionElement]) dispatchHTMLCaptionElementEvent(event string, snapshot HTMLCaptionElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLCaptionElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLCaptionElementState(prev HTMLCaptionElementState, payload map[string]any) HTMLCaptionElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLCaptionElementDefaults(ref *ElementRef[HTMLCaptionElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CaptionState()
			next := buildHTMLCaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCaptionElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLCaptionElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementFocus(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLCaptionElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementBlur(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLCaptionElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementClick(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLCaptionElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementDoubleClick(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLCaptionElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementContextMenu(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLCaptionElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementPointerDown(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLCaptionElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementPointerUp(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLCaptionElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementPointerMove(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLCaptionElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementPointerEnter(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLCaptionElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementPointerLeave(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLCaptionElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementPointerOver(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLCaptionElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementPointerOut(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLCaptionElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementPointerCancel(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLCaptionElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementWheel(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLCaptionElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementKeyDown(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLCaptionElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementKeyUp(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLCaptionElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLCaptionElement]) OnHTMLCaptionElementKeyPress(handler func(HTMLCaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGCircleElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// CircleState returns the cached snapshot for the <circle> element ref.
func (ref *ElementRef[SVGCircleElement]) CircleState() SVGCircleElementState {
	if ref == nil {
		return SVGCircleElementState{}
	}
	if raw, ok := ref.CachedState().(SVGCircleElementState); ok {
		return raw
	}
	return SVGCircleElementState{}
}

func (ref *ElementRef[SVGCircleElement]) dispatchSVGCircleElementEvent(event string, snapshot SVGCircleElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGCircleElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGCircleElementState(prev SVGCircleElementState, payload map[string]any) SVGCircleElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGCircleElementDefaults(ref *ElementRef[SVGCircleElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CircleState()
			next := buildSVGCircleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGCircleElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGCircleElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementFocus(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGCircleElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementBlur(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGCircleElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementClick(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGCircleElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementDoubleClick(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGCircleElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementContextMenu(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGCircleElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementPointerDown(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGCircleElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementPointerUp(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGCircleElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementPointerMove(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGCircleElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementPointerEnter(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGCircleElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementPointerLeave(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGCircleElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementPointerOver(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGCircleElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementPointerOut(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGCircleElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementPointerCancel(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGCircleElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementWheel(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGCircleElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementKeyDown(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGCircleElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementKeyUp(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGCircleElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGCircleElement]) OnSVGCircleElementKeyPress(handler func(SVGCircleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLCiteElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// CiteState returns the cached snapshot for the <cite> element ref.
func (ref *ElementRef[HTMLCiteElement]) CiteState() HTMLCiteElementState {
	if ref == nil {
		return HTMLCiteElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLCiteElementState); ok {
		return raw
	}
	return HTMLCiteElementState{}
}

func (ref *ElementRef[HTMLCiteElement]) dispatchHTMLCiteElementEvent(event string, snapshot HTMLCiteElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLCiteElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLCiteElementState(prev HTMLCiteElementState, payload map[string]any) HTMLCiteElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLCiteElementDefaults(ref *ElementRef[HTMLCiteElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CiteState()
			next := buildHTMLCiteElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCiteElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLCiteElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementFocus(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLCiteElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementBlur(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLCiteElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementClick(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLCiteElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementDoubleClick(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLCiteElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementContextMenu(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLCiteElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementPointerDown(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLCiteElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementPointerUp(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLCiteElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementPointerMove(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLCiteElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementPointerEnter(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLCiteElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementPointerLeave(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLCiteElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementPointerOver(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLCiteElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementPointerOut(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLCiteElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementPointerCancel(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLCiteElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementWheel(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLCiteElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementKeyDown(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLCiteElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementKeyUp(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLCiteElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLCiteElement]) OnHTMLCiteElementKeyPress(handler func(HTMLCiteElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGClipPathElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// ClipPathState returns the cached snapshot for the <clipPath> element ref.
func (ref *ElementRef[SVGClipPathElement]) ClipPathState() SVGClipPathElementState {
	if ref == nil {
		return SVGClipPathElementState{}
	}
	if raw, ok := ref.CachedState().(SVGClipPathElementState); ok {
		return raw
	}
	return SVGClipPathElementState{}
}

func (ref *ElementRef[SVGClipPathElement]) dispatchSVGClipPathElementEvent(event string, snapshot SVGClipPathElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGClipPathElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGClipPathElementState(prev SVGClipPathElementState, payload map[string]any) SVGClipPathElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGClipPathElementDefaults(ref *ElementRef[SVGClipPathElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ClipPathState()
			next := buildSVGClipPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGClipPathElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGClipPathElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementFocus(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGClipPathElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementBlur(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGClipPathElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementClick(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGClipPathElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementDoubleClick(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGClipPathElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementContextMenu(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGClipPathElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementPointerDown(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGClipPathElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementPointerUp(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGClipPathElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementPointerMove(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGClipPathElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementPointerEnter(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGClipPathElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementPointerLeave(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGClipPathElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementPointerOver(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGClipPathElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementPointerOut(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGClipPathElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementPointerCancel(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGClipPathElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementWheel(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGClipPathElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementKeyDown(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGClipPathElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementKeyUp(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGClipPathElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGClipPathElement]) OnSVGClipPathElementKeyPress(handler func(SVGClipPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLCodeElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// CodeState returns the cached snapshot for the <code> element ref.
func (ref *ElementRef[HTMLCodeElement]) CodeState() HTMLCodeElementState {
	if ref == nil {
		return HTMLCodeElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLCodeElementState); ok {
		return raw
	}
	return HTMLCodeElementState{}
}

func (ref *ElementRef[HTMLCodeElement]) dispatchHTMLCodeElementEvent(event string, snapshot HTMLCodeElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLCodeElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLCodeElementState(prev HTMLCodeElementState, payload map[string]any) HTMLCodeElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLCodeElementDefaults(ref *ElementRef[HTMLCodeElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CodeState()
			next := buildHTMLCodeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCodeElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLCodeElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementFocus(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLCodeElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementBlur(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLCodeElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementClick(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLCodeElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementDoubleClick(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLCodeElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementContextMenu(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLCodeElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementPointerDown(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLCodeElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementPointerUp(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLCodeElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementPointerMove(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLCodeElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementPointerEnter(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLCodeElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementPointerLeave(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLCodeElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementPointerOver(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLCodeElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementPointerOut(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLCodeElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementPointerCancel(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLCodeElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementWheel(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLCodeElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementKeyDown(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLCodeElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementKeyUp(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLCodeElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLCodeElement]) OnHTMLCodeElementKeyPress(handler func(HTMLCodeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLColElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// ColState returns the cached snapshot for the <col> element ref.
func (ref *ElementRef[HTMLColElement]) ColState() HTMLColElementState {
	if ref == nil {
		return HTMLColElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLColElementState); ok {
		return raw
	}
	return HTMLColElementState{}
}

func (ref *ElementRef[HTMLColElement]) dispatchHTMLColElementEvent(event string, snapshot HTMLColElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLColElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLColElementState(prev HTMLColElementState, payload map[string]any) HTMLColElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLColElementDefaults(ref *ElementRef[HTMLColElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColState()
			next := buildHTMLColElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLColElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementFocus(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLColElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementBlur(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLColElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementClick(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLColElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementDoubleClick(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLColElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementContextMenu(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLColElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementPointerDown(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLColElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementPointerUp(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLColElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementPointerMove(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLColElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementPointerEnter(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLColElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementPointerLeave(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLColElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementPointerOver(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLColElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementPointerOut(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLColElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementPointerCancel(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLColElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementWheel(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLColElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementKeyDown(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLColElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementKeyUp(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLColElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLColElement]) OnHTMLColElementKeyPress(handler func(HTMLColElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLColgroupElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// ColgroupState returns the cached snapshot for the <colgroup> element ref.
func (ref *ElementRef[HTMLColgroupElement]) ColgroupState() HTMLColgroupElementState {
	if ref == nil {
		return HTMLColgroupElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLColgroupElementState); ok {
		return raw
	}
	return HTMLColgroupElementState{}
}

func (ref *ElementRef[HTMLColgroupElement]) dispatchHTMLColgroupElementEvent(event string, snapshot HTMLColgroupElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLColgroupElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLColgroupElementState(prev HTMLColgroupElementState, payload map[string]any) HTMLColgroupElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLColgroupElementDefaults(ref *ElementRef[HTMLColgroupElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ColgroupState()
			next := buildHTMLColgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLColgroupElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLColgroupElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementFocus(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLColgroupElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementBlur(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLColgroupElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementClick(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLColgroupElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementDoubleClick(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLColgroupElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementContextMenu(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLColgroupElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementPointerDown(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLColgroupElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementPointerUp(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLColgroupElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementPointerMove(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLColgroupElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementPointerEnter(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLColgroupElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementPointerLeave(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLColgroupElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementPointerOver(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLColgroupElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementPointerOut(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLColgroupElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementPointerCancel(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLColgroupElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementWheel(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLColgroupElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementKeyDown(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLColgroupElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementKeyUp(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLColgroupElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLColgroupElement]) OnHTMLColgroupElementKeyPress(handler func(HTMLColgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLDataElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// DataElState returns the cached snapshot for the <data> element ref.
func (ref *ElementRef[HTMLDataElement]) DataElState() HTMLDataElementState {
	if ref == nil {
		return HTMLDataElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDataElementState); ok {
		return raw
	}
	return HTMLDataElementState{}
}

func (ref *ElementRef[HTMLDataElement]) dispatchHTMLDataElementEvent(event string, snapshot HTMLDataElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDataElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDataElementState(prev HTMLDataElementState, payload map[string]any) HTMLDataElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLDataElementDefaults(ref *ElementRef[HTMLDataElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DataElState()
			next := buildHTMLDataElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDataElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLDataElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementFocus(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLDataElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementBlur(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLDataElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementClick(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLDataElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementDoubleClick(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLDataElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementContextMenu(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLDataElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementPointerDown(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLDataElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementPointerUp(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLDataElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementPointerMove(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLDataElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementPointerEnter(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLDataElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementPointerLeave(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLDataElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementPointerOver(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLDataElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementPointerOut(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLDataElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementPointerCancel(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLDataElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementWheel(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLDataElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementKeyDown(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLDataElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementKeyUp(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLDataElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLDataElement]) OnHTMLDataElementKeyPress(handler func(HTMLDataElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLDatalistElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// DatalistState returns the cached snapshot for the <datalist> element ref.
func (ref *ElementRef[HTMLDatalistElement]) DatalistState() HTMLDatalistElementState {
	if ref == nil {
		return HTMLDatalistElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDatalistElementState); ok {
		return raw
	}
	return HTMLDatalistElementState{}
}

func (ref *ElementRef[HTMLDatalistElement]) dispatchHTMLDatalistElementEvent(event string, snapshot HTMLDatalistElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDatalistElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDatalistElementState(prev HTMLDatalistElementState, payload map[string]any) HTMLDatalistElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLDatalistElementDefaults(ref *ElementRef[HTMLDatalistElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DatalistState()
			next := buildHTMLDatalistElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDatalistElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLDatalistElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementFocus(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLDatalistElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementBlur(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLDatalistElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementClick(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLDatalistElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementDoubleClick(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLDatalistElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementContextMenu(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLDatalistElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementPointerDown(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLDatalistElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementPointerUp(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLDatalistElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementPointerMove(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLDatalistElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementPointerEnter(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLDatalistElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementPointerLeave(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLDatalistElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementPointerOver(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLDatalistElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementPointerOut(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLDatalistElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementPointerCancel(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLDatalistElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementWheel(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLDatalistElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementKeyDown(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLDatalistElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementKeyUp(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLDatalistElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLDatalistElement]) OnHTMLDatalistElementKeyPress(handler func(HTMLDatalistElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLDdElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// DdState returns the cached snapshot for the <dd> element ref.
func (ref *ElementRef[HTMLDdElement]) DdState() HTMLDdElementState {
	if ref == nil {
		return HTMLDdElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDdElementState); ok {
		return raw
	}
	return HTMLDdElementState{}
}

func (ref *ElementRef[HTMLDdElement]) dispatchHTMLDdElementEvent(event string, snapshot HTMLDdElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDdElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDdElementState(prev HTMLDdElementState, payload map[string]any) HTMLDdElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLDdElementDefaults(ref *ElementRef[HTMLDdElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DdState()
			next := buildHTMLDdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDdElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLDdElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementFocus(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLDdElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementBlur(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLDdElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementClick(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLDdElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementDoubleClick(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLDdElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementContextMenu(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLDdElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementPointerDown(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLDdElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementPointerUp(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLDdElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementPointerMove(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLDdElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementPointerEnter(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLDdElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementPointerLeave(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLDdElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementPointerOver(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLDdElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementPointerOut(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLDdElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementPointerCancel(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLDdElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementWheel(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLDdElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementKeyDown(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLDdElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementKeyUp(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLDdElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLDdElement]) OnHTMLDdElementKeyPress(handler func(HTMLDdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGDefsElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// DefsState returns the cached snapshot for the <defs> element ref.
func (ref *ElementRef[SVGDefsElement]) DefsState() SVGDefsElementState {
	if ref == nil {
		return SVGDefsElementState{}
	}
	if raw, ok := ref.CachedState().(SVGDefsElementState); ok {
		return raw
	}
	return SVGDefsElementState{}
}

func (ref *ElementRef[SVGDefsElement]) dispatchSVGDefsElementEvent(event string, snapshot SVGDefsElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGDefsElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGDefsElementState(prev SVGDefsElementState, payload map[string]any) SVGDefsElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGDefsElementDefaults(ref *ElementRef[SVGDefsElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DefsState()
			next := buildSVGDefsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGDefsElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGDefsElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementFocus(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGDefsElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementBlur(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGDefsElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementClick(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGDefsElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementDoubleClick(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGDefsElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementContextMenu(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGDefsElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementPointerDown(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGDefsElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementPointerUp(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGDefsElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementPointerMove(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGDefsElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementPointerEnter(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGDefsElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementPointerLeave(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGDefsElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementPointerOver(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGDefsElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementPointerOut(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGDefsElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementPointerCancel(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGDefsElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementWheel(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGDefsElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementKeyDown(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGDefsElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementKeyUp(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGDefsElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGDefsElement]) OnSVGDefsElementKeyPress(handler func(SVGDefsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLDelElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// DelElState returns the cached snapshot for the <del> element ref.
func (ref *ElementRef[HTMLDelElement]) DelElState() HTMLDelElementState {
	if ref == nil {
		return HTMLDelElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDelElementState); ok {
		return raw
	}
	return HTMLDelElementState{}
}

func (ref *ElementRef[HTMLDelElement]) dispatchHTMLDelElementEvent(event string, snapshot HTMLDelElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDelElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDelElementState(prev HTMLDelElementState, payload map[string]any) HTMLDelElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLDelElementDefaults(ref *ElementRef[HTMLDelElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DelElState()
			next := buildHTMLDelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDelElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLDelElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementFocus(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLDelElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementBlur(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLDelElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementClick(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLDelElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementDoubleClick(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLDelElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementContextMenu(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLDelElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementPointerDown(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLDelElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementPointerUp(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLDelElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementPointerMove(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLDelElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementPointerEnter(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLDelElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementPointerLeave(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLDelElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementPointerOver(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLDelElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementPointerOut(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLDelElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementPointerCancel(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLDelElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementWheel(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLDelElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementKeyDown(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLDelElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementKeyUp(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLDelElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLDelElement]) OnHTMLDelElementKeyPress(handler func(HTMLDelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLDetailsElementState struct {
	HTMLElementState
	HTMLKeyboardState
	Open bool
}

// DetailsState returns the cached snapshot for the <details> element ref.
func (ref *ElementRef[HTMLDetailsElement]) DetailsState() HTMLDetailsElementState {
	if ref == nil {
		return HTMLDetailsElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDetailsElementState); ok {
		return raw
	}
	return HTMLDetailsElementState{}
}

func (ref *ElementRef[HTMLDetailsElement]) dispatchHTMLDetailsElementEvent(event string, snapshot HTMLDetailsElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDetailsElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDetailsElementState(prev HTMLDetailsElementState, payload map[string]any) HTMLDetailsElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	next.Open = payloadBool(payload, "target.open", prev.Open)
	return next
}

func applyHTMLDetailsElementDefaults(ref *ElementRef[HTMLDetailsElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("toggle", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("toggle"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "toggle")
		ref.Bind("toggle", binding)
	}
}

// OnHTMLDetailsElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementFocus(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLDetailsElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementBlur(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLDetailsElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementClick(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLDetailsElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementDoubleClick(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLDetailsElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementContextMenu(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLDetailsElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementPointerDown(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLDetailsElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementPointerUp(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLDetailsElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementPointerMove(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLDetailsElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementPointerEnter(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLDetailsElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementPointerLeave(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLDetailsElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementPointerOver(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLDetailsElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementPointerOut(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLDetailsElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementPointerCancel(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLDetailsElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementWheel(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLDetailsElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementKeyDown(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLDetailsElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementKeyUp(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLDetailsElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLDetailsElement]) OnHTMLDetailsElementKeyPress(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnDetailsToggle registers a handler for the "toggle" event.
func (ref *ElementRef[HTMLDetailsElement]) OnDetailsToggle(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("toggle", handler)
}

type HTMLDfnElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// DfnState returns the cached snapshot for the <dfn> element ref.
func (ref *ElementRef[HTMLDfnElement]) DfnState() HTMLDfnElementState {
	if ref == nil {
		return HTMLDfnElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDfnElementState); ok {
		return raw
	}
	return HTMLDfnElementState{}
}

func (ref *ElementRef[HTMLDfnElement]) dispatchHTMLDfnElementEvent(event string, snapshot HTMLDfnElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDfnElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDfnElementState(prev HTMLDfnElementState, payload map[string]any) HTMLDfnElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLDfnElementDefaults(ref *ElementRef[HTMLDfnElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DfnState()
			next := buildHTMLDfnElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDfnElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLDfnElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementFocus(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLDfnElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementBlur(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLDfnElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementClick(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLDfnElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementDoubleClick(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLDfnElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementContextMenu(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLDfnElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementPointerDown(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLDfnElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementPointerUp(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLDfnElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementPointerMove(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLDfnElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementPointerEnter(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLDfnElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementPointerLeave(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLDfnElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementPointerOver(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLDfnElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementPointerOut(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLDfnElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementPointerCancel(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLDfnElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementWheel(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLDfnElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementKeyDown(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLDfnElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementKeyUp(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLDfnElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLDfnElement]) OnHTMLDfnElementKeyPress(handler func(HTMLDfnElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLDialogElementState struct {
	HTMLElementState
	HTMLKeyboardState
	Open        bool
	ReturnValue string
}

// DialogState returns the cached snapshot for the <dialog> element ref.
func (ref *ElementRef[HTMLDialogElement]) DialogState() HTMLDialogElementState {
	if ref == nil {
		return HTMLDialogElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDialogElementState); ok {
		return raw
	}
	return HTMLDialogElementState{}
}

func (ref *ElementRef[HTMLDialogElement]) dispatchHTMLDialogElementEvent(event string, snapshot HTMLDialogElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDialogElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDialogElementState(prev HTMLDialogElementState, payload map[string]any) HTMLDialogElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	next.Open = payloadBool(payload, "target.open", prev.Open)
	next.ReturnValue = payloadString(payload, "target.returnValue", prev.ReturnValue)
	return next
}

func applyHTMLDialogElementDefaults(ref *ElementRef[HTMLDialogElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("close", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("close"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "close")
		ref.Bind("close", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("cancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("cancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "cancel")
		ref.Bind("cancel", binding)
	}
}

// OnHTMLDialogElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementFocus(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLDialogElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementBlur(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLDialogElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementClick(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLDialogElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementDoubleClick(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLDialogElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementContextMenu(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLDialogElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementPointerDown(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLDialogElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementPointerUp(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLDialogElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementPointerMove(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLDialogElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementPointerEnter(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLDialogElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementPointerLeave(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLDialogElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementPointerOver(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLDialogElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementPointerOut(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLDialogElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementPointerCancel(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLDialogElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementWheel(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLDialogElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementKeyDown(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLDialogElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementKeyUp(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLDialogElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLDialogElement]) OnHTMLDialogElementKeyPress(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnDialogClose registers a handler for the "close" event.
func (ref *ElementRef[HTMLDialogElement]) OnDialogClose(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("close", handler)
}

// OnDialogCancel registers a handler for the "cancel" event.
func (ref *ElementRef[HTMLDialogElement]) OnDialogCancel(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("cancel", handler)
}

type HTMLDivElementState struct {
	HTMLElementState
	HTMLKeyboardState
	TargetID string
}

// DivState returns the cached snapshot for the <div> element ref.
func (ref *ElementRef[HTMLDivElement]) DivState() HTMLDivElementState {
	if ref == nil {
		return HTMLDivElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDivElementState); ok {
		return raw
	}
	return HTMLDivElementState{}
}

func (ref *ElementRef[HTMLDivElement]) dispatchHTMLDivElementEvent(event string, snapshot HTMLDivElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDivElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDivElementState(prev HTMLDivElementState, payload map[string]any) HTMLDivElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	next.TargetID = payloadString(payload, "target.id", prev.TargetID)
	return next
}

func applyHTMLDivElementDefaults(ref *ElementRef[HTMLDivElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("drag", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("drag"), EventOptions{
			Listen: []string{"dragstart", "dragend"},
			Props:  []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "drag")
		ref.Bind("drag", binding)
	}
}

// OnHTMLDivElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementFocus(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLDivElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementBlur(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLDivElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementClick(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLDivElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementDoubleClick(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLDivElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementContextMenu(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLDivElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementPointerDown(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLDivElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementPointerUp(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLDivElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementPointerMove(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLDivElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementPointerEnter(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLDivElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementPointerLeave(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLDivElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementPointerOver(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLDivElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementPointerOut(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLDivElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementPointerCancel(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLDivElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementWheel(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLDivElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementKeyDown(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLDivElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementKeyUp(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLDivElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLDivElement]) OnHTMLDivElementKeyPress(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnDivClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLDivElement]) OnDivClick(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnDivDrag registers a handler for the "drag" event.
func (ref *ElementRef[HTMLDivElement]) OnDivDrag(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("drag", handler)
}

type HTMLDlElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// DlState returns the cached snapshot for the <dl> element ref.
func (ref *ElementRef[HTMLDlElement]) DlState() HTMLDlElementState {
	if ref == nil {
		return HTMLDlElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDlElementState); ok {
		return raw
	}
	return HTMLDlElementState{}
}

func (ref *ElementRef[HTMLDlElement]) dispatchHTMLDlElementEvent(event string, snapshot HTMLDlElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDlElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDlElementState(prev HTMLDlElementState, payload map[string]any) HTMLDlElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLDlElementDefaults(ref *ElementRef[HTMLDlElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DlState()
			next := buildHTMLDlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDlElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLDlElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementFocus(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLDlElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementBlur(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLDlElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementClick(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLDlElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementDoubleClick(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLDlElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementContextMenu(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLDlElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementPointerDown(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLDlElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementPointerUp(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLDlElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementPointerMove(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLDlElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementPointerEnter(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLDlElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementPointerLeave(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLDlElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementPointerOver(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLDlElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementPointerOut(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLDlElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementPointerCancel(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLDlElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementWheel(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLDlElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementKeyDown(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLDlElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementKeyUp(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLDlElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLDlElement]) OnHTMLDlElementKeyPress(handler func(HTMLDlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLDtElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// DtState returns the cached snapshot for the <dt> element ref.
func (ref *ElementRef[HTMLDtElement]) DtState() HTMLDtElementState {
	if ref == nil {
		return HTMLDtElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDtElementState); ok {
		return raw
	}
	return HTMLDtElementState{}
}

func (ref *ElementRef[HTMLDtElement]) dispatchHTMLDtElementEvent(event string, snapshot HTMLDtElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDtElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDtElementState(prev HTMLDtElementState, payload map[string]any) HTMLDtElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLDtElementDefaults(ref *ElementRef[HTMLDtElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DtState()
			next := buildHTMLDtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDtElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLDtElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementFocus(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLDtElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementBlur(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLDtElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementClick(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLDtElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementDoubleClick(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLDtElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementContextMenu(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLDtElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementPointerDown(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLDtElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementPointerUp(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLDtElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementPointerMove(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLDtElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementPointerEnter(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLDtElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementPointerLeave(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLDtElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementPointerOver(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLDtElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementPointerOut(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLDtElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementPointerCancel(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLDtElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementWheel(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLDtElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementKeyDown(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLDtElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementKeyUp(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLDtElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLDtElement]) OnHTMLDtElementKeyPress(handler func(HTMLDtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGEllipseElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// EllipseState returns the cached snapshot for the <ellipse> element ref.
func (ref *ElementRef[SVGEllipseElement]) EllipseState() SVGEllipseElementState {
	if ref == nil {
		return SVGEllipseElementState{}
	}
	if raw, ok := ref.CachedState().(SVGEllipseElementState); ok {
		return raw
	}
	return SVGEllipseElementState{}
}

func (ref *ElementRef[SVGEllipseElement]) dispatchSVGEllipseElementEvent(event string, snapshot SVGEllipseElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGEllipseElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGEllipseElementState(prev SVGEllipseElementState, payload map[string]any) SVGEllipseElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGEllipseElementDefaults(ref *ElementRef[SVGEllipseElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EllipseState()
			next := buildSVGEllipseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGEllipseElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGEllipseElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementFocus(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGEllipseElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementBlur(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGEllipseElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementClick(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGEllipseElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementDoubleClick(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGEllipseElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementContextMenu(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGEllipseElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementPointerDown(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGEllipseElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementPointerUp(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGEllipseElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementPointerMove(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGEllipseElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementPointerEnter(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGEllipseElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementPointerLeave(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGEllipseElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementPointerOver(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGEllipseElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementPointerOut(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGEllipseElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementPointerCancel(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGEllipseElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementWheel(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGEllipseElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementKeyDown(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGEllipseElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementKeyUp(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGEllipseElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGEllipseElement]) OnSVGEllipseElementKeyPress(handler func(SVGEllipseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLEmElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// EmState returns the cached snapshot for the <em> element ref.
func (ref *ElementRef[HTMLEmElement]) EmState() HTMLEmElementState {
	if ref == nil {
		return HTMLEmElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLEmElementState); ok {
		return raw
	}
	return HTMLEmElementState{}
}

func (ref *ElementRef[HTMLEmElement]) dispatchHTMLEmElementEvent(event string, snapshot HTMLEmElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLEmElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLEmElementState(prev HTMLEmElementState, payload map[string]any) HTMLEmElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLEmElementDefaults(ref *ElementRef[HTMLEmElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmState()
			next := buildHTMLEmElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLEmElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementFocus(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLEmElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementBlur(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLEmElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementClick(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLEmElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementDoubleClick(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLEmElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementContextMenu(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLEmElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementPointerDown(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLEmElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementPointerUp(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLEmElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementPointerMove(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLEmElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementPointerEnter(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLEmElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementPointerLeave(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLEmElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementPointerOver(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLEmElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementPointerOut(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLEmElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementPointerCancel(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLEmElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementWheel(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLEmElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementKeyDown(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLEmElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementKeyUp(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLEmElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLEmElement]) OnHTMLEmElementKeyPress(handler func(HTMLEmElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLEmbedElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// EmbedState returns the cached snapshot for the <embed> element ref.
func (ref *ElementRef[HTMLEmbedElement]) EmbedState() HTMLEmbedElementState {
	if ref == nil {
		return HTMLEmbedElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLEmbedElementState); ok {
		return raw
	}
	return HTMLEmbedElementState{}
}

func (ref *ElementRef[HTMLEmbedElement]) dispatchHTMLEmbedElementEvent(event string, snapshot HTMLEmbedElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLEmbedElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLEmbedElementState(prev HTMLEmbedElementState, payload map[string]any) HTMLEmbedElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLEmbedElementDefaults(ref *ElementRef[HTMLEmbedElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.EmbedState()
			next := buildHTMLEmbedElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLEmbedElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLEmbedElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementFocus(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLEmbedElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementBlur(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLEmbedElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementClick(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLEmbedElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementDoubleClick(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLEmbedElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementContextMenu(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLEmbedElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementPointerDown(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLEmbedElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementPointerUp(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLEmbedElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementPointerMove(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLEmbedElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementPointerEnter(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLEmbedElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementPointerLeave(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLEmbedElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementPointerOver(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLEmbedElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementPointerOut(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLEmbedElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementPointerCancel(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLEmbedElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementWheel(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLEmbedElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementKeyDown(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLEmbedElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementKeyUp(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLEmbedElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLEmbedElement]) OnHTMLEmbedElementKeyPress(handler func(HTMLEmbedElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLFieldsetElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// FieldsetState returns the cached snapshot for the <fieldset> element ref.
func (ref *ElementRef[HTMLFieldsetElement]) FieldsetState() HTMLFieldsetElementState {
	if ref == nil {
		return HTMLFieldsetElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLFieldsetElementState); ok {
		return raw
	}
	return HTMLFieldsetElementState{}
}

func (ref *ElementRef[HTMLFieldsetElement]) dispatchHTMLFieldsetElementEvent(event string, snapshot HTMLFieldsetElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLFieldsetElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLFieldsetElementState(prev HTMLFieldsetElementState, payload map[string]any) HTMLFieldsetElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLFieldsetElementDefaults(ref *ElementRef[HTMLFieldsetElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FieldsetState()
			next := buildHTMLFieldsetElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFieldsetElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLFieldsetElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementFocus(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLFieldsetElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementBlur(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLFieldsetElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementClick(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLFieldsetElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementDoubleClick(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLFieldsetElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementContextMenu(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLFieldsetElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementPointerDown(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLFieldsetElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementPointerUp(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLFieldsetElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementPointerMove(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLFieldsetElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementPointerEnter(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLFieldsetElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementPointerLeave(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLFieldsetElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementPointerOver(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLFieldsetElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementPointerOut(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLFieldsetElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementPointerCancel(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLFieldsetElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementWheel(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLFieldsetElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementKeyDown(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLFieldsetElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementKeyUp(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLFieldsetElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLFieldsetElement]) OnHTMLFieldsetElementKeyPress(handler func(HTMLFieldsetElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLFigcaptionElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// FigcaptionState returns the cached snapshot for the <figcaption> element ref.
func (ref *ElementRef[HTMLFigcaptionElement]) FigcaptionState() HTMLFigcaptionElementState {
	if ref == nil {
		return HTMLFigcaptionElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLFigcaptionElementState); ok {
		return raw
	}
	return HTMLFigcaptionElementState{}
}

func (ref *ElementRef[HTMLFigcaptionElement]) dispatchHTMLFigcaptionElementEvent(event string, snapshot HTMLFigcaptionElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLFigcaptionElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLFigcaptionElementState(prev HTMLFigcaptionElementState, payload map[string]any) HTMLFigcaptionElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLFigcaptionElementDefaults(ref *ElementRef[HTMLFigcaptionElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigcaptionState()
			next := buildHTMLFigcaptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigcaptionElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLFigcaptionElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementFocus(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLFigcaptionElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementBlur(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLFigcaptionElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementClick(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLFigcaptionElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementDoubleClick(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLFigcaptionElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementContextMenu(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLFigcaptionElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementPointerDown(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLFigcaptionElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementPointerUp(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLFigcaptionElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementPointerMove(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLFigcaptionElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementPointerEnter(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLFigcaptionElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementPointerLeave(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLFigcaptionElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementPointerOver(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLFigcaptionElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementPointerOut(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLFigcaptionElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementPointerCancel(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLFigcaptionElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementWheel(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLFigcaptionElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementKeyDown(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLFigcaptionElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementKeyUp(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLFigcaptionElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLFigcaptionElement]) OnHTMLFigcaptionElementKeyPress(handler func(HTMLFigcaptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLFigureElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// FigureState returns the cached snapshot for the <figure> element ref.
func (ref *ElementRef[HTMLFigureElement]) FigureState() HTMLFigureElementState {
	if ref == nil {
		return HTMLFigureElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLFigureElementState); ok {
		return raw
	}
	return HTMLFigureElementState{}
}

func (ref *ElementRef[HTMLFigureElement]) dispatchHTMLFigureElementEvent(event string, snapshot HTMLFigureElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLFigureElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLFigureElementState(prev HTMLFigureElementState, payload map[string]any) HTMLFigureElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLFigureElementDefaults(ref *ElementRef[HTMLFigureElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FigureState()
			next := buildHTMLFigureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFigureElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLFigureElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementFocus(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLFigureElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementBlur(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLFigureElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementClick(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLFigureElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementDoubleClick(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLFigureElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementContextMenu(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLFigureElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementPointerDown(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLFigureElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementPointerUp(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLFigureElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementPointerMove(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLFigureElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementPointerEnter(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLFigureElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementPointerLeave(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLFigureElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementPointerOver(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLFigureElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementPointerOut(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLFigureElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementPointerCancel(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLFigureElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementWheel(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLFigureElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementKeyDown(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLFigureElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementKeyUp(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLFigureElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLFigureElement]) OnHTMLFigureElementKeyPress(handler func(HTMLFigureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLFooterElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// FooterState returns the cached snapshot for the <footer> element ref.
func (ref *ElementRef[HTMLFooterElement]) FooterState() HTMLFooterElementState {
	if ref == nil {
		return HTMLFooterElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLFooterElementState); ok {
		return raw
	}
	return HTMLFooterElementState{}
}

func (ref *ElementRef[HTMLFooterElement]) dispatchHTMLFooterElementEvent(event string, snapshot HTMLFooterElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLFooterElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLFooterElementState(prev HTMLFooterElementState, payload map[string]any) HTMLFooterElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLFooterElementDefaults(ref *ElementRef[HTMLFooterElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FooterState()
			next := buildHTMLFooterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFooterElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLFooterElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementFocus(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLFooterElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementBlur(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLFooterElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementClick(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLFooterElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementDoubleClick(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLFooterElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementContextMenu(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLFooterElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementPointerDown(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLFooterElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementPointerUp(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLFooterElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementPointerMove(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLFooterElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementPointerEnter(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLFooterElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementPointerLeave(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLFooterElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementPointerOver(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLFooterElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementPointerOut(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLFooterElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementPointerCancel(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLFooterElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementWheel(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLFooterElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementKeyDown(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLFooterElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementKeyUp(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLFooterElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLFooterElement]) OnHTMLFooterElementKeyPress(handler func(HTMLFooterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGForeignObjectElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// ForeignObjectState returns the cached snapshot for the <foreignObject> element ref.
func (ref *ElementRef[SVGForeignObjectElement]) ForeignObjectState() SVGForeignObjectElementState {
	if ref == nil {
		return SVGForeignObjectElementState{}
	}
	if raw, ok := ref.CachedState().(SVGForeignObjectElementState); ok {
		return raw
	}
	return SVGForeignObjectElementState{}
}

func (ref *ElementRef[SVGForeignObjectElement]) dispatchSVGForeignObjectElementEvent(event string, snapshot SVGForeignObjectElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGForeignObjectElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGForeignObjectElementState(prev SVGForeignObjectElementState, payload map[string]any) SVGForeignObjectElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGForeignObjectElementDefaults(ref *ElementRef[SVGForeignObjectElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ForeignObjectState()
			next := buildSVGForeignObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGForeignObjectElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGForeignObjectElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementFocus(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGForeignObjectElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementBlur(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGForeignObjectElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementClick(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGForeignObjectElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementDoubleClick(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGForeignObjectElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementContextMenu(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGForeignObjectElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementPointerDown(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGForeignObjectElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementPointerUp(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGForeignObjectElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementPointerMove(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGForeignObjectElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementPointerEnter(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGForeignObjectElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementPointerLeave(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGForeignObjectElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementPointerOver(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGForeignObjectElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementPointerOut(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGForeignObjectElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementPointerCancel(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGForeignObjectElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementWheel(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGForeignObjectElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementKeyDown(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGForeignObjectElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementKeyUp(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGForeignObjectElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGForeignObjectElement]) OnSVGForeignObjectElementKeyPress(handler func(SVGForeignObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLFormElementState struct {
	HTMLElementState
	HTMLKeyboardState
	Action     string
	Method     string
	NoValidate bool
	Target     string
	Encoding   string
	Name       string
}

// FormState returns the cached snapshot for the <form> element ref.
func (ref *ElementRef[HTMLFormElement]) FormState() HTMLFormElementState {
	if ref == nil {
		return HTMLFormElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLFormElementState); ok {
		return raw
	}
	return HTMLFormElementState{}
}

func (ref *ElementRef[HTMLFormElement]) dispatchHTMLFormElementEvent(event string, snapshot HTMLFormElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLFormElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLFormElementState(prev HTMLFormElementState, payload map[string]any) HTMLFormElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	next.Action = payloadString(payload, "target.action", prev.Action)
	next.Method = payloadString(payload, "target.method", prev.Method)
	next.NoValidate = payloadBool(payload, "target.noValidate", prev.NoValidate)
	next.Target = payloadString(payload, "target.target", prev.Target)
	next.Encoding = payloadString(payload, "target.enctype", prev.Encoding)
	next.Name = payloadString(payload, "target.name", prev.Name)
	return next
}

func applyHTMLFormElementDefaults(ref *ElementRef[HTMLFormElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("submit", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("submit"), EventOptions{
			Listen: []string{"formdata"},
			Props:  []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "submit")
		ref.Bind("submit", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("reset", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("reset"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "reset")
		ref.Bind("reset", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("invalid", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("invalid"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "invalid")
		ref.Bind("invalid", binding)
	}
}

// OnHTMLFormElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementFocus(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLFormElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementBlur(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLFormElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementClick(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLFormElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementDoubleClick(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLFormElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementContextMenu(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLFormElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementPointerDown(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLFormElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementPointerUp(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLFormElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementPointerMove(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLFormElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementPointerEnter(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLFormElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementPointerLeave(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLFormElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementPointerOver(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLFormElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementPointerOut(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLFormElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementPointerCancel(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLFormElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementWheel(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLFormElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementKeyDown(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLFormElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementKeyUp(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLFormElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLFormElement]) OnHTMLFormElementKeyPress(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnFormSubmit registers a handler for the "submit" event.
func (ref *ElementRef[HTMLFormElement]) OnFormSubmit(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("submit", handler)
}

// OnFormReset registers a handler for the "reset" event.
func (ref *ElementRef[HTMLFormElement]) OnFormReset(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("reset", handler)
}

// OnFormInvalid registers a handler for the "invalid" event.
func (ref *ElementRef[HTMLFormElement]) OnFormInvalid(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("invalid", handler)
}

type SVGGElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// GState returns the cached snapshot for the <g> element ref.
func (ref *ElementRef[SVGGElement]) GState() SVGGElementState {
	if ref == nil {
		return SVGGElementState{}
	}
	if raw, ok := ref.CachedState().(SVGGElementState); ok {
		return raw
	}
	return SVGGElementState{}
}

func (ref *ElementRef[SVGGElement]) dispatchSVGGElementEvent(event string, snapshot SVGGElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGGElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGGElementState(prev SVGGElementState, payload map[string]any) SVGGElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGGElementDefaults(ref *ElementRef[SVGGElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.GState()
			next := buildSVGGElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGGElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGGElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementFocus(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGGElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementBlur(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGGElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementClick(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGGElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementDoubleClick(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGGElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementContextMenu(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGGElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementPointerDown(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGGElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementPointerUp(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGGElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementPointerMove(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGGElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementPointerEnter(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGGElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementPointerLeave(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGGElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementPointerOver(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGGElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementPointerOut(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGGElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementPointerCancel(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGGElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementWheel(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGGElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementKeyDown(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGGElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementKeyUp(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGGElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGGElement]) OnSVGGElementKeyPress(handler func(SVGGElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLH1ElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// H1State returns the cached snapshot for the <h1> element ref.
func (ref *ElementRef[HTMLH1Element]) H1State() HTMLH1ElementState {
	if ref == nil {
		return HTMLH1ElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLH1ElementState); ok {
		return raw
	}
	return HTMLH1ElementState{}
}

func (ref *ElementRef[HTMLH1Element]) dispatchHTMLH1ElementEvent(event string, snapshot HTMLH1ElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLH1ElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLH1ElementState(prev HTMLH1ElementState, payload map[string]any) HTMLH1ElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLH1ElementDefaults(ref *ElementRef[HTMLH1Element]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H1State()
			next := buildHTMLH1ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH1ElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLH1ElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementFocus(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLH1ElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementBlur(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLH1ElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementClick(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLH1ElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementDoubleClick(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLH1ElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementContextMenu(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLH1ElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementPointerDown(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLH1ElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementPointerUp(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLH1ElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementPointerMove(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLH1ElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementPointerEnter(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLH1ElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementPointerLeave(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLH1ElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementPointerOver(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLH1ElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementPointerOut(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLH1ElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementPointerCancel(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLH1ElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementWheel(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLH1ElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementKeyDown(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLH1ElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementKeyUp(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLH1ElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLH1Element]) OnHTMLH1ElementKeyPress(handler func(HTMLH1ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLH2ElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// H2State returns the cached snapshot for the <h2> element ref.
func (ref *ElementRef[HTMLH2Element]) H2State() HTMLH2ElementState {
	if ref == nil {
		return HTMLH2ElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLH2ElementState); ok {
		return raw
	}
	return HTMLH2ElementState{}
}

func (ref *ElementRef[HTMLH2Element]) dispatchHTMLH2ElementEvent(event string, snapshot HTMLH2ElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLH2ElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLH2ElementState(prev HTMLH2ElementState, payload map[string]any) HTMLH2ElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLH2ElementDefaults(ref *ElementRef[HTMLH2Element]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H2State()
			next := buildHTMLH2ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH2ElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLH2ElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementFocus(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLH2ElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementBlur(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLH2ElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementClick(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLH2ElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementDoubleClick(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLH2ElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementContextMenu(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLH2ElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementPointerDown(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLH2ElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementPointerUp(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLH2ElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementPointerMove(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLH2ElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementPointerEnter(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLH2ElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementPointerLeave(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLH2ElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementPointerOver(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLH2ElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementPointerOut(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLH2ElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementPointerCancel(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLH2ElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementWheel(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLH2ElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementKeyDown(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLH2ElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementKeyUp(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLH2ElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLH2Element]) OnHTMLH2ElementKeyPress(handler func(HTMLH2ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLH3ElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// H3State returns the cached snapshot for the <h3> element ref.
func (ref *ElementRef[HTMLH3Element]) H3State() HTMLH3ElementState {
	if ref == nil {
		return HTMLH3ElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLH3ElementState); ok {
		return raw
	}
	return HTMLH3ElementState{}
}

func (ref *ElementRef[HTMLH3Element]) dispatchHTMLH3ElementEvent(event string, snapshot HTMLH3ElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLH3ElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLH3ElementState(prev HTMLH3ElementState, payload map[string]any) HTMLH3ElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLH3ElementDefaults(ref *ElementRef[HTMLH3Element]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H3State()
			next := buildHTMLH3ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH3ElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLH3ElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementFocus(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLH3ElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementBlur(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLH3ElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementClick(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLH3ElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementDoubleClick(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLH3ElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementContextMenu(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLH3ElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementPointerDown(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLH3ElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementPointerUp(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLH3ElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementPointerMove(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLH3ElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementPointerEnter(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLH3ElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementPointerLeave(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLH3ElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementPointerOver(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLH3ElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementPointerOut(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLH3ElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementPointerCancel(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLH3ElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementWheel(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLH3ElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementKeyDown(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLH3ElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementKeyUp(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLH3ElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLH3Element]) OnHTMLH3ElementKeyPress(handler func(HTMLH3ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLH4ElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// H4State returns the cached snapshot for the <h4> element ref.
func (ref *ElementRef[HTMLH4Element]) H4State() HTMLH4ElementState {
	if ref == nil {
		return HTMLH4ElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLH4ElementState); ok {
		return raw
	}
	return HTMLH4ElementState{}
}

func (ref *ElementRef[HTMLH4Element]) dispatchHTMLH4ElementEvent(event string, snapshot HTMLH4ElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLH4ElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLH4ElementState(prev HTMLH4ElementState, payload map[string]any) HTMLH4ElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLH4ElementDefaults(ref *ElementRef[HTMLH4Element]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H4State()
			next := buildHTMLH4ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH4ElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLH4ElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementFocus(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLH4ElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementBlur(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLH4ElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementClick(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLH4ElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementDoubleClick(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLH4ElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementContextMenu(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLH4ElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementPointerDown(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLH4ElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementPointerUp(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLH4ElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementPointerMove(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLH4ElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementPointerEnter(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLH4ElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementPointerLeave(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLH4ElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementPointerOver(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLH4ElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementPointerOut(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLH4ElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementPointerCancel(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLH4ElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementWheel(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLH4ElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementKeyDown(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLH4ElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementKeyUp(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLH4ElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLH4Element]) OnHTMLH4ElementKeyPress(handler func(HTMLH4ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLH5ElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// H5State returns the cached snapshot for the <h5> element ref.
func (ref *ElementRef[HTMLH5Element]) H5State() HTMLH5ElementState {
	if ref == nil {
		return HTMLH5ElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLH5ElementState); ok {
		return raw
	}
	return HTMLH5ElementState{}
}

func (ref *ElementRef[HTMLH5Element]) dispatchHTMLH5ElementEvent(event string, snapshot HTMLH5ElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLH5ElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLH5ElementState(prev HTMLH5ElementState, payload map[string]any) HTMLH5ElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLH5ElementDefaults(ref *ElementRef[HTMLH5Element]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H5State()
			next := buildHTMLH5ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH5ElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLH5ElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementFocus(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLH5ElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementBlur(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLH5ElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementClick(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLH5ElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementDoubleClick(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLH5ElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementContextMenu(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLH5ElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementPointerDown(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLH5ElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementPointerUp(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLH5ElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementPointerMove(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLH5ElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementPointerEnter(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLH5ElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementPointerLeave(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLH5ElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementPointerOver(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLH5ElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementPointerOut(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLH5ElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementPointerCancel(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLH5ElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementWheel(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLH5ElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementKeyDown(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLH5ElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementKeyUp(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLH5ElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLH5Element]) OnHTMLH5ElementKeyPress(handler func(HTMLH5ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLH6ElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// H6State returns the cached snapshot for the <h6> element ref.
func (ref *ElementRef[HTMLH6Element]) H6State() HTMLH6ElementState {
	if ref == nil {
		return HTMLH6ElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLH6ElementState); ok {
		return raw
	}
	return HTMLH6ElementState{}
}

func (ref *ElementRef[HTMLH6Element]) dispatchHTMLH6ElementEvent(event string, snapshot HTMLH6ElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLH6ElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLH6ElementState(prev HTMLH6ElementState, payload map[string]any) HTMLH6ElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLH6ElementDefaults(ref *ElementRef[HTMLH6Element]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.H6State()
			next := buildHTMLH6ElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLH6ElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLH6ElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementFocus(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLH6ElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementBlur(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLH6ElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementClick(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLH6ElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementDoubleClick(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLH6ElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementContextMenu(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLH6ElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementPointerDown(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLH6ElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementPointerUp(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLH6ElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementPointerMove(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLH6ElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementPointerEnter(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLH6ElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementPointerLeave(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLH6ElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementPointerOver(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLH6ElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementPointerOut(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLH6ElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementPointerCancel(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLH6ElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementWheel(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLH6ElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementKeyDown(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLH6ElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementKeyUp(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLH6ElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLH6Element]) OnHTMLH6ElementKeyPress(handler func(HTMLH6ElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLHeadElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// HeadState returns the cached snapshot for the <head> element ref.
func (ref *ElementRef[HTMLHeadElement]) HeadState() HTMLHeadElementState {
	if ref == nil {
		return HTMLHeadElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLHeadElementState); ok {
		return raw
	}
	return HTMLHeadElementState{}
}

func (ref *ElementRef[HTMLHeadElement]) dispatchHTMLHeadElementEvent(event string, snapshot HTMLHeadElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLHeadElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLHeadElementState(prev HTMLHeadElementState, payload map[string]any) HTMLHeadElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLHeadElementDefaults(ref *ElementRef[HTMLHeadElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeadState()
			next := buildHTMLHeadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeadElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLHeadElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementFocus(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLHeadElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementBlur(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLHeadElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementClick(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLHeadElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementDoubleClick(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLHeadElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementContextMenu(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLHeadElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementPointerDown(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLHeadElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementPointerUp(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLHeadElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementPointerMove(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLHeadElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementPointerEnter(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLHeadElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementPointerLeave(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLHeadElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementPointerOver(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLHeadElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementPointerOut(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLHeadElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementPointerCancel(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLHeadElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementWheel(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLHeadElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementKeyDown(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLHeadElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementKeyUp(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLHeadElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLHeadElement]) OnHTMLHeadElementKeyPress(handler func(HTMLHeadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLHeaderElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// HeaderState returns the cached snapshot for the <header> element ref.
func (ref *ElementRef[HTMLHeaderElement]) HeaderState() HTMLHeaderElementState {
	if ref == nil {
		return HTMLHeaderElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLHeaderElementState); ok {
		return raw
	}
	return HTMLHeaderElementState{}
}

func (ref *ElementRef[HTMLHeaderElement]) dispatchHTMLHeaderElementEvent(event string, snapshot HTMLHeaderElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLHeaderElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLHeaderElementState(prev HTMLHeaderElementState, payload map[string]any) HTMLHeaderElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLHeaderElementDefaults(ref *ElementRef[HTMLHeaderElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HeaderState()
			next := buildHTMLHeaderElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHeaderElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLHeaderElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementFocus(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLHeaderElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementBlur(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLHeaderElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementClick(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLHeaderElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementDoubleClick(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLHeaderElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementContextMenu(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLHeaderElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementPointerDown(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLHeaderElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementPointerUp(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLHeaderElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementPointerMove(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLHeaderElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementPointerEnter(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLHeaderElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementPointerLeave(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLHeaderElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementPointerOver(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLHeaderElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementPointerOut(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLHeaderElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementPointerCancel(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLHeaderElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementWheel(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLHeaderElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementKeyDown(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLHeaderElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementKeyUp(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLHeaderElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLHeaderElement]) OnHTMLHeaderElementKeyPress(handler func(HTMLHeaderElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLHgroupElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// HgroupState returns the cached snapshot for the <hgroup> element ref.
func (ref *ElementRef[HTMLHgroupElement]) HgroupState() HTMLHgroupElementState {
	if ref == nil {
		return HTMLHgroupElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLHgroupElementState); ok {
		return raw
	}
	return HTMLHgroupElementState{}
}

func (ref *ElementRef[HTMLHgroupElement]) dispatchHTMLHgroupElementEvent(event string, snapshot HTMLHgroupElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLHgroupElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLHgroupElementState(prev HTMLHgroupElementState, payload map[string]any) HTMLHgroupElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLHgroupElementDefaults(ref *ElementRef[HTMLHgroupElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HgroupState()
			next := buildHTMLHgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHgroupElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLHgroupElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementFocus(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLHgroupElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementBlur(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLHgroupElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementClick(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLHgroupElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementDoubleClick(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLHgroupElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementContextMenu(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLHgroupElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementPointerDown(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLHgroupElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementPointerUp(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLHgroupElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementPointerMove(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLHgroupElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementPointerEnter(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLHgroupElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementPointerLeave(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLHgroupElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementPointerOver(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLHgroupElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementPointerOut(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLHgroupElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementPointerCancel(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLHgroupElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementWheel(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLHgroupElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementKeyDown(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLHgroupElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementKeyUp(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLHgroupElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLHgroupElement]) OnHTMLHgroupElementKeyPress(handler func(HTMLHgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLHrElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// HrState returns the cached snapshot for the <hr> element ref.
func (ref *ElementRef[HTMLHrElement]) HrState() HTMLHrElementState {
	if ref == nil {
		return HTMLHrElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLHrElementState); ok {
		return raw
	}
	return HTMLHrElementState{}
}

func (ref *ElementRef[HTMLHrElement]) dispatchHTMLHrElementEvent(event string, snapshot HTMLHrElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLHrElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLHrElementState(prev HTMLHrElementState, payload map[string]any) HTMLHrElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLHrElementDefaults(ref *ElementRef[HTMLHrElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HrState()
			next := buildHTMLHrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHrElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLHrElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementFocus(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLHrElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementBlur(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLHrElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementClick(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLHrElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementDoubleClick(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLHrElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementContextMenu(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLHrElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementPointerDown(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLHrElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementPointerUp(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLHrElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementPointerMove(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLHrElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementPointerEnter(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLHrElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementPointerLeave(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLHrElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementPointerOver(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLHrElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementPointerOut(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLHrElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementPointerCancel(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLHrElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementWheel(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLHrElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementKeyDown(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLHrElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementKeyUp(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLHrElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLHrElement]) OnHTMLHrElementKeyPress(handler func(HTMLHrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLHtmlElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// HtmlState returns the cached snapshot for the <html> element ref.
func (ref *ElementRef[HTMLHtmlElement]) HtmlState() HTMLHtmlElementState {
	if ref == nil {
		return HTMLHtmlElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLHtmlElementState); ok {
		return raw
	}
	return HTMLHtmlElementState{}
}

func (ref *ElementRef[HTMLHtmlElement]) dispatchHTMLHtmlElementEvent(event string, snapshot HTMLHtmlElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLHtmlElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLHtmlElementState(prev HTMLHtmlElementState, payload map[string]any) HTMLHtmlElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLHtmlElementDefaults(ref *ElementRef[HTMLHtmlElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.HtmlState()
			next := buildHTMLHtmlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLHtmlElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLHtmlElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementFocus(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLHtmlElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementBlur(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLHtmlElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementClick(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLHtmlElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementDoubleClick(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLHtmlElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementContextMenu(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLHtmlElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementPointerDown(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLHtmlElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementPointerUp(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLHtmlElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementPointerMove(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLHtmlElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementPointerEnter(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLHtmlElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementPointerLeave(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLHtmlElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementPointerOver(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLHtmlElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementPointerOut(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLHtmlElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementPointerCancel(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLHtmlElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementWheel(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLHtmlElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementKeyDown(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLHtmlElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementKeyUp(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLHtmlElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLHtmlElement]) OnHTMLHtmlElementKeyPress(handler func(HTMLHtmlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLIElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// IState returns the cached snapshot for the <i> element ref.
func (ref *ElementRef[HTMLIElement]) IState() HTMLIElementState {
	if ref == nil {
		return HTMLIElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLIElementState); ok {
		return raw
	}
	return HTMLIElementState{}
}

func (ref *ElementRef[HTMLIElement]) dispatchHTMLIElementEvent(event string, snapshot HTMLIElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLIElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLIElementState(prev HTMLIElementState, payload map[string]any) HTMLIElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLIElementDefaults(ref *ElementRef[HTMLIElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IState()
			next := buildHTMLIElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLIElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementFocus(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLIElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementBlur(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLIElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementClick(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLIElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementDoubleClick(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLIElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementContextMenu(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLIElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementPointerDown(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLIElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementPointerUp(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLIElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementPointerMove(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLIElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementPointerEnter(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLIElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementPointerLeave(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLIElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementPointerOver(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLIElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementPointerOut(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLIElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementPointerCancel(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLIElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementWheel(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLIElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementKeyDown(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLIElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementKeyUp(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLIElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLIElement]) OnHTMLIElementKeyPress(handler func(HTMLIElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLIframeElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// IframeState returns the cached snapshot for the <iframe> element ref.
func (ref *ElementRef[HTMLIframeElement]) IframeState() HTMLIframeElementState {
	if ref == nil {
		return HTMLIframeElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLIframeElementState); ok {
		return raw
	}
	return HTMLIframeElementState{}
}

func (ref *ElementRef[HTMLIframeElement]) dispatchHTMLIframeElementEvent(event string, snapshot HTMLIframeElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLIframeElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLIframeElementState(prev HTMLIframeElementState, payload map[string]any) HTMLIframeElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLIframeElementDefaults(ref *ElementRef[HTMLIframeElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.IframeState()
			next := buildHTMLIframeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLIframeElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLIframeElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementFocus(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLIframeElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementBlur(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLIframeElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementClick(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLIframeElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementDoubleClick(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLIframeElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementContextMenu(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLIframeElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementPointerDown(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLIframeElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementPointerUp(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLIframeElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementPointerMove(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLIframeElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementPointerEnter(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLIframeElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementPointerLeave(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLIframeElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementPointerOver(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLIframeElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementPointerOut(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLIframeElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementPointerCancel(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLIframeElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementWheel(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLIframeElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementKeyDown(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLIframeElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementKeyUp(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLIframeElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLIframeElement]) OnHTMLIframeElementKeyPress(handler func(HTMLIframeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGImageElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// ImageState returns the cached snapshot for the <image> element ref.
func (ref *ElementRef[SVGImageElement]) ImageState() SVGImageElementState {
	if ref == nil {
		return SVGImageElementState{}
	}
	if raw, ok := ref.CachedState().(SVGImageElementState); ok {
		return raw
	}
	return SVGImageElementState{}
}

func (ref *ElementRef[SVGImageElement]) dispatchSVGImageElementEvent(event string, snapshot SVGImageElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGImageElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGImageElementState(prev SVGImageElementState, payload map[string]any) SVGImageElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGImageElementDefaults(ref *ElementRef[SVGImageElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImageState()
			next := buildSVGImageElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGImageElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGImageElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementFocus(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGImageElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementBlur(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGImageElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementClick(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGImageElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementDoubleClick(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGImageElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementContextMenu(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGImageElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementPointerDown(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGImageElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementPointerUp(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGImageElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementPointerMove(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGImageElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementPointerEnter(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGImageElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementPointerLeave(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGImageElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementPointerOver(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGImageElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementPointerOut(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGImageElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementPointerCancel(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGImageElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementWheel(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGImageElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementKeyDown(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGImageElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementKeyUp(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGImageElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGImageElement]) OnSVGImageElementKeyPress(handler func(SVGImageElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLImgElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// ImgState returns the cached snapshot for the <img> element ref.
func (ref *ElementRef[HTMLImgElement]) ImgState() HTMLImgElementState {
	if ref == nil {
		return HTMLImgElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLImgElementState); ok {
		return raw
	}
	return HTMLImgElementState{}
}

func (ref *ElementRef[HTMLImgElement]) dispatchHTMLImgElementEvent(event string, snapshot HTMLImgElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLImgElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLImgElementState(prev HTMLImgElementState, payload map[string]any) HTMLImgElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLImgElementDefaults(ref *ElementRef[HTMLImgElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ImgState()
			next := buildHTMLImgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLImgElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLImgElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementFocus(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLImgElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementBlur(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLImgElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementClick(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLImgElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementDoubleClick(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLImgElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementContextMenu(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLImgElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementPointerDown(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLImgElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementPointerUp(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLImgElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementPointerMove(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLImgElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementPointerEnter(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLImgElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementPointerLeave(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLImgElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementPointerOver(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLImgElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementPointerOut(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLImgElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementPointerCancel(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLImgElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementWheel(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLImgElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementKeyDown(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLImgElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementKeyUp(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLImgElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLImgElement]) OnHTMLImgElementKeyPress(handler func(HTMLImgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLInputElementState struct {
	HTMLElementState
	HTMLKeyboardState
	Value          string
	Checked        bool
	Type           string
	Name           string
	Disabled       bool
	Required       bool
	SelectionStart int
	SelectionEnd   int
}

// InputState returns the cached snapshot for the <input> element ref.
func (ref *ElementRef[HTMLInputElement]) InputState() HTMLInputElementState {
	if ref == nil {
		return HTMLInputElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLInputElementState); ok {
		return raw
	}
	return HTMLInputElementState{}
}

func (ref *ElementRef[HTMLInputElement]) dispatchHTMLInputElementEvent(event string, snapshot HTMLInputElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLInputElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLInputElementState(prev HTMLInputElementState, payload map[string]any) HTMLInputElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	next.Value = payloadString(payload, "target.value", prev.Value)
	next.Checked = payloadBool(payload, "target.checked", prev.Checked)
	next.Type = payloadString(payload, "target.type", prev.Type)
	next.Name = payloadString(payload, "target.name", prev.Name)
	next.Disabled = payloadBool(payload, "target.disabled", prev.Disabled)
	next.Required = payloadBool(payload, "target.required", prev.Required)
	next.SelectionStart = payloadInt(payload, "target.selectionStart", prev.SelectionStart)
	next.SelectionEnd = payloadInt(payload, "target.selectionEnd", prev.SelectionEnd)
	return next
}

func applyHTMLInputElementDefaults(ref *ElementRef[HTMLInputElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("input", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("input"), EventOptions{
			Props: []string{"event.inputType", "event.isComposing", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "input")
		ref.Bind("input", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("change", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("change"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "change")
		ref.Bind("change", binding)
	}
}

// OnHTMLInputElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementFocus(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLInputElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementBlur(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLInputElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementClick(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLInputElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementDoubleClick(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLInputElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementContextMenu(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLInputElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementPointerDown(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLInputElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementPointerUp(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLInputElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementPointerMove(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLInputElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementPointerEnter(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLInputElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementPointerLeave(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLInputElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementPointerOver(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLInputElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementPointerOut(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLInputElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementPointerCancel(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLInputElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementWheel(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLInputElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementKeyDown(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLInputElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementKeyUp(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLInputElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLInputElement]) OnHTMLInputElementKeyPress(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnInput registers a handler for the "input" event.
func (ref *ElementRef[HTMLInputElement]) OnInput(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("input", handler)
}

// OnChange registers a handler for the "change" event.
func (ref *ElementRef[HTMLInputElement]) OnChange(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("change", handler)
}

type HTMLInsElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// InsElState returns the cached snapshot for the <ins> element ref.
func (ref *ElementRef[HTMLInsElement]) InsElState() HTMLInsElementState {
	if ref == nil {
		return HTMLInsElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLInsElementState); ok {
		return raw
	}
	return HTMLInsElementState{}
}

func (ref *ElementRef[HTMLInsElement]) dispatchHTMLInsElementEvent(event string, snapshot HTMLInsElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLInsElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLInsElementState(prev HTMLInsElementState, payload map[string]any) HTMLInsElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLInsElementDefaults(ref *ElementRef[HTMLInsElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InsElState()
			next := buildHTMLInsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInsElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLInsElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementFocus(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLInsElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementBlur(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLInsElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementClick(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLInsElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementDoubleClick(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLInsElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementContextMenu(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLInsElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementPointerDown(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLInsElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementPointerUp(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLInsElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementPointerMove(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLInsElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementPointerEnter(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLInsElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementPointerLeave(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLInsElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementPointerOver(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLInsElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementPointerOut(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLInsElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementPointerCancel(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLInsElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementWheel(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLInsElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementKeyDown(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLInsElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementKeyUp(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLInsElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLInsElement]) OnHTMLInsElementKeyPress(handler func(HTMLInsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLKbdElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// KbdState returns the cached snapshot for the <kbd> element ref.
func (ref *ElementRef[HTMLKbdElement]) KbdState() HTMLKbdElementState {
	if ref == nil {
		return HTMLKbdElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLKbdElementState); ok {
		return raw
	}
	return HTMLKbdElementState{}
}

func (ref *ElementRef[HTMLKbdElement]) dispatchHTMLKbdElementEvent(event string, snapshot HTMLKbdElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLKbdElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLKbdElementState(prev HTMLKbdElementState, payload map[string]any) HTMLKbdElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLKbdElementDefaults(ref *ElementRef[HTMLKbdElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.KbdState()
			next := buildHTMLKbdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLKbdElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLKbdElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementFocus(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLKbdElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementBlur(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLKbdElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementClick(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLKbdElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementDoubleClick(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLKbdElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementContextMenu(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLKbdElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementPointerDown(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLKbdElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementPointerUp(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLKbdElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementPointerMove(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLKbdElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementPointerEnter(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLKbdElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementPointerLeave(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLKbdElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementPointerOver(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLKbdElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementPointerOut(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLKbdElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementPointerCancel(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLKbdElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementWheel(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLKbdElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementKeyDown(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLKbdElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementKeyUp(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLKbdElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLKbdElement]) OnHTMLKbdElementKeyPress(handler func(HTMLKbdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLLabelElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// LabelState returns the cached snapshot for the <label> element ref.
func (ref *ElementRef[HTMLLabelElement]) LabelState() HTMLLabelElementState {
	if ref == nil {
		return HTMLLabelElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLLabelElementState); ok {
		return raw
	}
	return HTMLLabelElementState{}
}

func (ref *ElementRef[HTMLLabelElement]) dispatchHTMLLabelElementEvent(event string, snapshot HTMLLabelElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLLabelElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLLabelElementState(prev HTMLLabelElementState, payload map[string]any) HTMLLabelElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLLabelElementDefaults(ref *ElementRef[HTMLLabelElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LabelState()
			next := buildHTMLLabelElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLabelElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLLabelElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementFocus(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLLabelElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementBlur(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLLabelElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementClick(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLLabelElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementDoubleClick(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLLabelElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementContextMenu(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLLabelElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementPointerDown(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLLabelElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementPointerUp(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLLabelElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementPointerMove(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLLabelElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementPointerEnter(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLLabelElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementPointerLeave(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLLabelElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementPointerOver(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLLabelElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementPointerOut(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLLabelElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementPointerCancel(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLLabelElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementWheel(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLLabelElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementKeyDown(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLLabelElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementKeyUp(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLLabelElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLLabelElement]) OnHTMLLabelElementKeyPress(handler func(HTMLLabelElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLLegendElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// LegendState returns the cached snapshot for the <legend> element ref.
func (ref *ElementRef[HTMLLegendElement]) LegendState() HTMLLegendElementState {
	if ref == nil {
		return HTMLLegendElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLLegendElementState); ok {
		return raw
	}
	return HTMLLegendElementState{}
}

func (ref *ElementRef[HTMLLegendElement]) dispatchHTMLLegendElementEvent(event string, snapshot HTMLLegendElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLLegendElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLLegendElementState(prev HTMLLegendElementState, payload map[string]any) HTMLLegendElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLLegendElementDefaults(ref *ElementRef[HTMLLegendElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LegendState()
			next := buildHTMLLegendElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLegendElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLLegendElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementFocus(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLLegendElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementBlur(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLLegendElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementClick(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLLegendElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementDoubleClick(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLLegendElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementContextMenu(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLLegendElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementPointerDown(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLLegendElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementPointerUp(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLLegendElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementPointerMove(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLLegendElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementPointerEnter(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLLegendElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementPointerLeave(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLLegendElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementPointerOver(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLLegendElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementPointerOut(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLLegendElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementPointerCancel(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLLegendElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementWheel(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLLegendElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementKeyDown(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLLegendElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementKeyUp(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLLegendElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLLegendElement]) OnHTMLLegendElementKeyPress(handler func(HTMLLegendElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLLiElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// LiState returns the cached snapshot for the <li> element ref.
func (ref *ElementRef[HTMLLiElement]) LiState() HTMLLiElementState {
	if ref == nil {
		return HTMLLiElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLLiElementState); ok {
		return raw
	}
	return HTMLLiElementState{}
}

func (ref *ElementRef[HTMLLiElement]) dispatchHTMLLiElementEvent(event string, snapshot HTMLLiElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLLiElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLLiElementState(prev HTMLLiElementState, payload map[string]any) HTMLLiElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLLiElementDefaults(ref *ElementRef[HTMLLiElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LiState()
			next := buildHTMLLiElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLiElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLLiElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementFocus(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLLiElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementBlur(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLLiElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementClick(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLLiElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementDoubleClick(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLLiElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementContextMenu(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLLiElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementPointerDown(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLLiElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementPointerUp(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLLiElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementPointerMove(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLLiElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementPointerEnter(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLLiElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementPointerLeave(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLLiElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementPointerOver(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLLiElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementPointerOut(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLLiElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementPointerCancel(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLLiElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementWheel(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLLiElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementKeyDown(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLLiElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementKeyUp(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLLiElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLLiElement]) OnHTMLLiElementKeyPress(handler func(HTMLLiElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGLineElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// LineState returns the cached snapshot for the <line> element ref.
func (ref *ElementRef[SVGLineElement]) LineState() SVGLineElementState {
	if ref == nil {
		return SVGLineElementState{}
	}
	if raw, ok := ref.CachedState().(SVGLineElementState); ok {
		return raw
	}
	return SVGLineElementState{}
}

func (ref *ElementRef[SVGLineElement]) dispatchSVGLineElementEvent(event string, snapshot SVGLineElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGLineElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGLineElementState(prev SVGLineElementState, payload map[string]any) SVGLineElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGLineElementDefaults(ref *ElementRef[SVGLineElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LineState()
			next := buildSVGLineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLineElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGLineElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementFocus(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGLineElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementBlur(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGLineElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementClick(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGLineElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementDoubleClick(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGLineElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementContextMenu(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGLineElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementPointerDown(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGLineElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementPointerUp(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGLineElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementPointerMove(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGLineElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementPointerEnter(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGLineElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementPointerLeave(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGLineElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementPointerOver(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGLineElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementPointerOut(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGLineElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementPointerCancel(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGLineElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementWheel(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGLineElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementKeyDown(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGLineElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementKeyUp(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGLineElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGLineElement]) OnSVGLineElementKeyPress(handler func(SVGLineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGLinearGradientElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// LinearGradientState returns the cached snapshot for the <linearGradient> element ref.
func (ref *ElementRef[SVGLinearGradientElement]) LinearGradientState() SVGLinearGradientElementState {
	if ref == nil {
		return SVGLinearGradientElementState{}
	}
	if raw, ok := ref.CachedState().(SVGLinearGradientElementState); ok {
		return raw
	}
	return SVGLinearGradientElementState{}
}

func (ref *ElementRef[SVGLinearGradientElement]) dispatchSVGLinearGradientElementEvent(event string, snapshot SVGLinearGradientElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGLinearGradientElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGLinearGradientElementState(prev SVGLinearGradientElementState, payload map[string]any) SVGLinearGradientElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGLinearGradientElementDefaults(ref *ElementRef[SVGLinearGradientElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinearGradientState()
			next := buildSVGLinearGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGLinearGradientElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGLinearGradientElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementFocus(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGLinearGradientElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementBlur(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGLinearGradientElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementClick(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGLinearGradientElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementDoubleClick(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGLinearGradientElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementContextMenu(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGLinearGradientElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementPointerDown(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGLinearGradientElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementPointerUp(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGLinearGradientElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementPointerMove(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGLinearGradientElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementPointerEnter(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGLinearGradientElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementPointerLeave(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGLinearGradientElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementPointerOver(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGLinearGradientElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementPointerOut(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGLinearGradientElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementPointerCancel(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGLinearGradientElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementWheel(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGLinearGradientElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementKeyDown(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGLinearGradientElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementKeyUp(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGLinearGradientElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGLinearGradientElement]) OnSVGLinearGradientElementKeyPress(handler func(SVGLinearGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLLinkElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// LinkState returns the cached snapshot for the <link> element ref.
func (ref *ElementRef[HTMLLinkElement]) LinkState() HTMLLinkElementState {
	if ref == nil {
		return HTMLLinkElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLLinkElementState); ok {
		return raw
	}
	return HTMLLinkElementState{}
}

func (ref *ElementRef[HTMLLinkElement]) dispatchHTMLLinkElementEvent(event string, snapshot HTMLLinkElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLLinkElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLLinkElementState(prev HTMLLinkElementState, payload map[string]any) HTMLLinkElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLLinkElementDefaults(ref *ElementRef[HTMLLinkElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.LinkState()
			next := buildHTMLLinkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLLinkElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLLinkElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementFocus(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLLinkElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementBlur(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLLinkElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementClick(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLLinkElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementDoubleClick(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLLinkElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementContextMenu(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLLinkElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementPointerDown(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLLinkElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementPointerUp(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLLinkElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementPointerMove(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLLinkElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementPointerEnter(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLLinkElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementPointerLeave(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLLinkElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementPointerOver(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLLinkElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementPointerOut(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLLinkElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementPointerCancel(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLLinkElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementWheel(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLLinkElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementKeyDown(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLLinkElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementKeyUp(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLLinkElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLLinkElement]) OnHTMLLinkElementKeyPress(handler func(HTMLLinkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLMainElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// MainState returns the cached snapshot for the <main> element ref.
func (ref *ElementRef[HTMLMainElement]) MainState() HTMLMainElementState {
	if ref == nil {
		return HTMLMainElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLMainElementState); ok {
		return raw
	}
	return HTMLMainElementState{}
}

func (ref *ElementRef[HTMLMainElement]) dispatchHTMLMainElementEvent(event string, snapshot HTMLMainElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLMainElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLMainElementState(prev HTMLMainElementState, payload map[string]any) HTMLMainElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLMainElementDefaults(ref *ElementRef[HTMLMainElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MainState()
			next := buildHTMLMainElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMainElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLMainElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementFocus(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLMainElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementBlur(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLMainElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementClick(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLMainElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementDoubleClick(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLMainElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementContextMenu(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLMainElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementPointerDown(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLMainElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementPointerUp(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLMainElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementPointerMove(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLMainElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementPointerEnter(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLMainElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementPointerLeave(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLMainElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementPointerOver(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLMainElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementPointerOut(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLMainElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementPointerCancel(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLMainElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementWheel(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLMainElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementKeyDown(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLMainElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementKeyUp(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLMainElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLMainElement]) OnHTMLMainElementKeyPress(handler func(HTMLMainElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLMapElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// MapElState returns the cached snapshot for the <map> element ref.
func (ref *ElementRef[HTMLMapElement]) MapElState() HTMLMapElementState {
	if ref == nil {
		return HTMLMapElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLMapElementState); ok {
		return raw
	}
	return HTMLMapElementState{}
}

func (ref *ElementRef[HTMLMapElement]) dispatchHTMLMapElementEvent(event string, snapshot HTMLMapElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLMapElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLMapElementState(prev HTMLMapElementState, payload map[string]any) HTMLMapElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLMapElementDefaults(ref *ElementRef[HTMLMapElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MapElState()
			next := buildHTMLMapElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMapElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLMapElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementFocus(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLMapElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementBlur(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLMapElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementClick(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLMapElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementDoubleClick(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLMapElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementContextMenu(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLMapElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementPointerDown(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLMapElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementPointerUp(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLMapElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementPointerMove(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLMapElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementPointerEnter(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLMapElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementPointerLeave(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLMapElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementPointerOver(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLMapElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementPointerOut(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLMapElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementPointerCancel(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLMapElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementWheel(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLMapElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementKeyDown(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLMapElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementKeyUp(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLMapElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLMapElement]) OnHTMLMapElementKeyPress(handler func(HTMLMapElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLMarkElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// MarkState returns the cached snapshot for the <mark> element ref.
func (ref *ElementRef[HTMLMarkElement]) MarkState() HTMLMarkElementState {
	if ref == nil {
		return HTMLMarkElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLMarkElementState); ok {
		return raw
	}
	return HTMLMarkElementState{}
}

func (ref *ElementRef[HTMLMarkElement]) dispatchHTMLMarkElementEvent(event string, snapshot HTMLMarkElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLMarkElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLMarkElementState(prev HTMLMarkElementState, payload map[string]any) HTMLMarkElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLMarkElementDefaults(ref *ElementRef[HTMLMarkElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkState()
			next := buildHTMLMarkElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMarkElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLMarkElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementFocus(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLMarkElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementBlur(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLMarkElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementClick(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLMarkElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementDoubleClick(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLMarkElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementContextMenu(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLMarkElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementPointerDown(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLMarkElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementPointerUp(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLMarkElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementPointerMove(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLMarkElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementPointerEnter(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLMarkElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementPointerLeave(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLMarkElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementPointerOver(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLMarkElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementPointerOut(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLMarkElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementPointerCancel(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLMarkElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementWheel(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLMarkElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementKeyDown(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLMarkElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementKeyUp(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLMarkElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLMarkElement]) OnHTMLMarkElementKeyPress(handler func(HTMLMarkElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGMarkerElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// MarkerState returns the cached snapshot for the <marker> element ref.
func (ref *ElementRef[SVGMarkerElement]) MarkerState() SVGMarkerElementState {
	if ref == nil {
		return SVGMarkerElementState{}
	}
	if raw, ok := ref.CachedState().(SVGMarkerElementState); ok {
		return raw
	}
	return SVGMarkerElementState{}
}

func (ref *ElementRef[SVGMarkerElement]) dispatchSVGMarkerElementEvent(event string, snapshot SVGMarkerElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGMarkerElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGMarkerElementState(prev SVGMarkerElementState, payload map[string]any) SVGMarkerElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGMarkerElementDefaults(ref *ElementRef[SVGMarkerElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MarkerState()
			next := buildSVGMarkerElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMarkerElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGMarkerElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementFocus(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGMarkerElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementBlur(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGMarkerElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementClick(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGMarkerElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementDoubleClick(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGMarkerElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementContextMenu(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGMarkerElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementPointerDown(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGMarkerElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementPointerUp(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGMarkerElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementPointerMove(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGMarkerElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementPointerEnter(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGMarkerElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementPointerLeave(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGMarkerElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementPointerOver(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGMarkerElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementPointerOut(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGMarkerElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementPointerCancel(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGMarkerElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementWheel(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGMarkerElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementKeyDown(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGMarkerElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementKeyUp(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGMarkerElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGMarkerElement]) OnSVGMarkerElementKeyPress(handler func(SVGMarkerElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGMaskElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// MaskState returns the cached snapshot for the <mask> element ref.
func (ref *ElementRef[SVGMaskElement]) MaskState() SVGMaskElementState {
	if ref == nil {
		return SVGMaskElementState{}
	}
	if raw, ok := ref.CachedState().(SVGMaskElementState); ok {
		return raw
	}
	return SVGMaskElementState{}
}

func (ref *ElementRef[SVGMaskElement]) dispatchSVGMaskElementEvent(event string, snapshot SVGMaskElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGMaskElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGMaskElementState(prev SVGMaskElementState, payload map[string]any) SVGMaskElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGMaskElementDefaults(ref *ElementRef[SVGMaskElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MaskState()
			next := buildSVGMaskElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGMaskElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGMaskElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementFocus(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGMaskElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementBlur(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGMaskElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementClick(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGMaskElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementDoubleClick(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGMaskElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementContextMenu(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGMaskElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementPointerDown(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGMaskElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementPointerUp(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGMaskElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementPointerMove(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGMaskElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementPointerEnter(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGMaskElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementPointerLeave(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGMaskElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementPointerOver(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGMaskElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementPointerOut(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGMaskElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementPointerCancel(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGMaskElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementWheel(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGMaskElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementKeyDown(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGMaskElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementKeyUp(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGMaskElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGMaskElement]) OnSVGMaskElementKeyPress(handler func(SVGMaskElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLMenuElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// MenuState returns the cached snapshot for the <menu> element ref.
func (ref *ElementRef[HTMLMenuElement]) MenuState() HTMLMenuElementState {
	if ref == nil {
		return HTMLMenuElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLMenuElementState); ok {
		return raw
	}
	return HTMLMenuElementState{}
}

func (ref *ElementRef[HTMLMenuElement]) dispatchHTMLMenuElementEvent(event string, snapshot HTMLMenuElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLMenuElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLMenuElementState(prev HTMLMenuElementState, payload map[string]any) HTMLMenuElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLMenuElementDefaults(ref *ElementRef[HTMLMenuElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuState()
			next := buildHTMLMenuElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLMenuElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementFocus(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLMenuElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementBlur(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLMenuElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementClick(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLMenuElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementDoubleClick(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLMenuElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementContextMenu(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLMenuElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementPointerDown(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLMenuElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementPointerUp(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLMenuElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementPointerMove(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLMenuElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementPointerEnter(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLMenuElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementPointerLeave(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLMenuElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementPointerOver(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLMenuElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementPointerOut(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLMenuElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementPointerCancel(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLMenuElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementWheel(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLMenuElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementKeyDown(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLMenuElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementKeyUp(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLMenuElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLMenuElement]) OnHTMLMenuElementKeyPress(handler func(HTMLMenuElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLMenuItemElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// MenuItemState returns the cached snapshot for the <menuitem> element ref.
func (ref *ElementRef[HTMLMenuItemElement]) MenuItemState() HTMLMenuItemElementState {
	if ref == nil {
		return HTMLMenuItemElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLMenuItemElementState); ok {
		return raw
	}
	return HTMLMenuItemElementState{}
}

func (ref *ElementRef[HTMLMenuItemElement]) dispatchHTMLMenuItemElementEvent(event string, snapshot HTMLMenuItemElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLMenuItemElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLMenuItemElementState(prev HTMLMenuItemElementState, payload map[string]any) HTMLMenuItemElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLMenuItemElementDefaults(ref *ElementRef[HTMLMenuItemElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MenuItemState()
			next := buildHTMLMenuItemElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMenuItemElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLMenuItemElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementFocus(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLMenuItemElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementBlur(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLMenuItemElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementClick(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLMenuItemElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementDoubleClick(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLMenuItemElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementContextMenu(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLMenuItemElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementPointerDown(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLMenuItemElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementPointerUp(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLMenuItemElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementPointerMove(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLMenuItemElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementPointerEnter(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLMenuItemElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementPointerLeave(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLMenuItemElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementPointerOver(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLMenuItemElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementPointerOut(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLMenuItemElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementPointerCancel(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLMenuItemElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementWheel(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLMenuItemElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementKeyDown(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLMenuItemElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementKeyUp(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLMenuItemElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLMenuItemElement]) OnHTMLMenuItemElementKeyPress(handler func(HTMLMenuItemElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLMetaElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// MetaState returns the cached snapshot for the <meta> element ref.
func (ref *ElementRef[HTMLMetaElement]) MetaState() HTMLMetaElementState {
	if ref == nil {
		return HTMLMetaElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLMetaElementState); ok {
		return raw
	}
	return HTMLMetaElementState{}
}

func (ref *ElementRef[HTMLMetaElement]) dispatchHTMLMetaElementEvent(event string, snapshot HTMLMetaElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLMetaElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLMetaElementState(prev HTMLMetaElementState, payload map[string]any) HTMLMetaElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLMetaElementDefaults(ref *ElementRef[HTMLMetaElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MetaState()
			next := buildHTMLMetaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMetaElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLMetaElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementFocus(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLMetaElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementBlur(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLMetaElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementClick(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLMetaElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementDoubleClick(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLMetaElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementContextMenu(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLMetaElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementPointerDown(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLMetaElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementPointerUp(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLMetaElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementPointerMove(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLMetaElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementPointerEnter(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLMetaElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementPointerLeave(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLMetaElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementPointerOver(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLMetaElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementPointerOut(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLMetaElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementPointerCancel(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLMetaElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementWheel(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLMetaElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementKeyDown(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLMetaElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementKeyUp(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLMetaElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLMetaElement]) OnHTMLMetaElementKeyPress(handler func(HTMLMetaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLMeterElementState struct {
	HTMLElementState
	HTMLKeyboardState
	Value   float64
	Min     float64
	Max     float64
	Low     float64
	High    float64
	Optimum float64
}

// MeterState returns the cached snapshot for the <meter> element ref.
func (ref *ElementRef[HTMLMeterElement]) MeterState() HTMLMeterElementState {
	if ref == nil {
		return HTMLMeterElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLMeterElementState); ok {
		return raw
	}
	return HTMLMeterElementState{}
}

func (ref *ElementRef[HTMLMeterElement]) dispatchHTMLMeterElementEvent(event string, snapshot HTMLMeterElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLMeterElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLMeterElementState(prev HTMLMeterElementState, payload map[string]any) HTMLMeterElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	next.Value = payloadFloat(payload, "target.value", prev.Value)
	next.Min = payloadFloat(payload, "target.min", prev.Min)
	next.Max = payloadFloat(payload, "target.max", prev.Max)
	next.Low = payloadFloat(payload, "target.low", prev.Low)
	next.High = payloadFloat(payload, "target.high", prev.High)
	next.Optimum = payloadFloat(payload, "target.optimum", prev.Optimum)
	return next
}

func applyHTMLMeterElementDefaults(ref *ElementRef[HTMLMeterElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("change", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("change"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "change")
		ref.Bind("change", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("input", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("input"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "input")
		ref.Bind("input", binding)
	}
}

// OnHTMLMeterElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementFocus(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLMeterElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementBlur(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLMeterElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementClick(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLMeterElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementDoubleClick(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLMeterElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementContextMenu(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLMeterElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementPointerDown(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLMeterElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementPointerUp(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLMeterElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementPointerMove(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLMeterElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementPointerEnter(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLMeterElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementPointerLeave(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLMeterElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementPointerOver(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLMeterElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementPointerOut(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLMeterElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementPointerCancel(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLMeterElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementWheel(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLMeterElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementKeyDown(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLMeterElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementKeyUp(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLMeterElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLMeterElement]) OnHTMLMeterElementKeyPress(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnMeterChange registers a handler for the "change" event.
func (ref *ElementRef[HTMLMeterElement]) OnMeterChange(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("change", handler)
}

// OnMeterInput registers a handler for the "input" event.
func (ref *ElementRef[HTMLMeterElement]) OnMeterInput(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("input", handler)
}

type HTMLNavElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// NavState returns the cached snapshot for the <nav> element ref.
func (ref *ElementRef[HTMLNavElement]) NavState() HTMLNavElementState {
	if ref == nil {
		return HTMLNavElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLNavElementState); ok {
		return raw
	}
	return HTMLNavElementState{}
}

func (ref *ElementRef[HTMLNavElement]) dispatchHTMLNavElementEvent(event string, snapshot HTMLNavElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLNavElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLNavElementState(prev HTMLNavElementState, payload map[string]any) HTMLNavElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLNavElementDefaults(ref *ElementRef[HTMLNavElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NavState()
			next := buildHTMLNavElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNavElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLNavElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementFocus(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLNavElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementBlur(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLNavElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementClick(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLNavElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementDoubleClick(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLNavElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementContextMenu(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLNavElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementPointerDown(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLNavElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementPointerUp(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLNavElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementPointerMove(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLNavElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementPointerEnter(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLNavElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementPointerLeave(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLNavElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementPointerOver(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLNavElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementPointerOut(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLNavElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementPointerCancel(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLNavElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementWheel(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLNavElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementKeyDown(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLNavElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementKeyUp(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLNavElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLNavElement]) OnHTMLNavElementKeyPress(handler func(HTMLNavElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLNoscriptElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// NoscriptState returns the cached snapshot for the <noscript> element ref.
func (ref *ElementRef[HTMLNoscriptElement]) NoscriptState() HTMLNoscriptElementState {
	if ref == nil {
		return HTMLNoscriptElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLNoscriptElementState); ok {
		return raw
	}
	return HTMLNoscriptElementState{}
}

func (ref *ElementRef[HTMLNoscriptElement]) dispatchHTMLNoscriptElementEvent(event string, snapshot HTMLNoscriptElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLNoscriptElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLNoscriptElementState(prev HTMLNoscriptElementState, payload map[string]any) HTMLNoscriptElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLNoscriptElementDefaults(ref *ElementRef[HTMLNoscriptElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.NoscriptState()
			next := buildHTMLNoscriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLNoscriptElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLNoscriptElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementFocus(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLNoscriptElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementBlur(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLNoscriptElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementClick(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLNoscriptElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementDoubleClick(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLNoscriptElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementContextMenu(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLNoscriptElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementPointerDown(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLNoscriptElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementPointerUp(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLNoscriptElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementPointerMove(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLNoscriptElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementPointerEnter(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLNoscriptElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementPointerLeave(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLNoscriptElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementPointerOver(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLNoscriptElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementPointerOut(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLNoscriptElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementPointerCancel(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLNoscriptElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementWheel(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLNoscriptElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementKeyDown(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLNoscriptElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementKeyUp(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLNoscriptElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLNoscriptElement]) OnHTMLNoscriptElementKeyPress(handler func(HTMLNoscriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLObjectElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// ObjectState returns the cached snapshot for the <object> element ref.
func (ref *ElementRef[HTMLObjectElement]) ObjectState() HTMLObjectElementState {
	if ref == nil {
		return HTMLObjectElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLObjectElementState); ok {
		return raw
	}
	return HTMLObjectElementState{}
}

func (ref *ElementRef[HTMLObjectElement]) dispatchHTMLObjectElementEvent(event string, snapshot HTMLObjectElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLObjectElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLObjectElementState(prev HTMLObjectElementState, payload map[string]any) HTMLObjectElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLObjectElementDefaults(ref *ElementRef[HTMLObjectElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ObjectState()
			next := buildHTMLObjectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLObjectElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLObjectElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementFocus(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLObjectElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementBlur(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLObjectElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementClick(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLObjectElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementDoubleClick(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLObjectElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementContextMenu(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLObjectElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementPointerDown(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLObjectElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementPointerUp(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLObjectElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementPointerMove(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLObjectElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementPointerEnter(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLObjectElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementPointerLeave(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLObjectElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementPointerOver(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLObjectElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementPointerOut(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLObjectElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementPointerCancel(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLObjectElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementWheel(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLObjectElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementKeyDown(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLObjectElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementKeyUp(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLObjectElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLObjectElement]) OnHTMLObjectElementKeyPress(handler func(HTMLObjectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLOlElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// OlState returns the cached snapshot for the <ol> element ref.
func (ref *ElementRef[HTMLOlElement]) OlState() HTMLOlElementState {
	if ref == nil {
		return HTMLOlElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLOlElementState); ok {
		return raw
	}
	return HTMLOlElementState{}
}

func (ref *ElementRef[HTMLOlElement]) dispatchHTMLOlElementEvent(event string, snapshot HTMLOlElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLOlElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLOlElementState(prev HTMLOlElementState, payload map[string]any) HTMLOlElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLOlElementDefaults(ref *ElementRef[HTMLOlElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OlState()
			next := buildHTMLOlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOlElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLOlElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementFocus(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLOlElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementBlur(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLOlElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementClick(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLOlElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementDoubleClick(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLOlElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementContextMenu(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLOlElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementPointerDown(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLOlElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementPointerUp(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLOlElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementPointerMove(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLOlElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementPointerEnter(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLOlElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementPointerLeave(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLOlElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementPointerOver(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLOlElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementPointerOut(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLOlElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementPointerCancel(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLOlElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementWheel(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLOlElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementKeyDown(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLOlElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementKeyUp(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLOlElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLOlElement]) OnHTMLOlElementKeyPress(handler func(HTMLOlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLOptgroupElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// OptgroupState returns the cached snapshot for the <optgroup> element ref.
func (ref *ElementRef[HTMLOptgroupElement]) OptgroupState() HTMLOptgroupElementState {
	if ref == nil {
		return HTMLOptgroupElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLOptgroupElementState); ok {
		return raw
	}
	return HTMLOptgroupElementState{}
}

func (ref *ElementRef[HTMLOptgroupElement]) dispatchHTMLOptgroupElementEvent(event string, snapshot HTMLOptgroupElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLOptgroupElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLOptgroupElementState(prev HTMLOptgroupElementState, payload map[string]any) HTMLOptgroupElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLOptgroupElementDefaults(ref *ElementRef[HTMLOptgroupElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptgroupState()
			next := buildHTMLOptgroupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptgroupElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLOptgroupElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementFocus(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLOptgroupElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementBlur(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLOptgroupElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementClick(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLOptgroupElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementDoubleClick(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLOptgroupElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementContextMenu(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLOptgroupElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementPointerDown(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLOptgroupElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementPointerUp(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLOptgroupElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementPointerMove(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLOptgroupElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementPointerEnter(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLOptgroupElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementPointerLeave(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLOptgroupElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementPointerOver(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLOptgroupElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementPointerOut(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLOptgroupElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementPointerCancel(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLOptgroupElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementWheel(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLOptgroupElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementKeyDown(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLOptgroupElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementKeyUp(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLOptgroupElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLOptgroupElement]) OnHTMLOptgroupElementKeyPress(handler func(HTMLOptgroupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLOptionElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// OptionState returns the cached snapshot for the <option> element ref.
func (ref *ElementRef[HTMLOptionElement]) OptionState() HTMLOptionElementState {
	if ref == nil {
		return HTMLOptionElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLOptionElementState); ok {
		return raw
	}
	return HTMLOptionElementState{}
}

func (ref *ElementRef[HTMLOptionElement]) dispatchHTMLOptionElementEvent(event string, snapshot HTMLOptionElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLOptionElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLOptionElementState(prev HTMLOptionElementState, payload map[string]any) HTMLOptionElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLOptionElementDefaults(ref *ElementRef[HTMLOptionElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OptionState()
			next := buildHTMLOptionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOptionElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLOptionElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementFocus(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLOptionElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementBlur(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLOptionElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementClick(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLOptionElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementDoubleClick(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLOptionElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementContextMenu(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLOptionElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementPointerDown(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLOptionElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementPointerUp(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLOptionElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementPointerMove(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLOptionElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementPointerEnter(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLOptionElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementPointerLeave(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLOptionElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementPointerOver(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLOptionElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementPointerOut(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLOptionElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementPointerCancel(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLOptionElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementWheel(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLOptionElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementKeyDown(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLOptionElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementKeyUp(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLOptionElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLOptionElement]) OnHTMLOptionElementKeyPress(handler func(HTMLOptionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLOutputElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// OutputState returns the cached snapshot for the <output> element ref.
func (ref *ElementRef[HTMLOutputElement]) OutputState() HTMLOutputElementState {
	if ref == nil {
		return HTMLOutputElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLOutputElementState); ok {
		return raw
	}
	return HTMLOutputElementState{}
}

func (ref *ElementRef[HTMLOutputElement]) dispatchHTMLOutputElementEvent(event string, snapshot HTMLOutputElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLOutputElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLOutputElementState(prev HTMLOutputElementState, payload map[string]any) HTMLOutputElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLOutputElementDefaults(ref *ElementRef[HTMLOutputElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.OutputState()
			next := buildHTMLOutputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLOutputElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLOutputElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementFocus(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLOutputElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementBlur(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLOutputElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementClick(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLOutputElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementDoubleClick(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLOutputElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementContextMenu(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLOutputElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementPointerDown(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLOutputElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementPointerUp(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLOutputElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementPointerMove(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLOutputElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementPointerEnter(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLOutputElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementPointerLeave(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLOutputElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementPointerOver(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLOutputElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementPointerOut(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLOutputElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementPointerCancel(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLOutputElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementWheel(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLOutputElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementKeyDown(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLOutputElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementKeyUp(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLOutputElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLOutputElement]) OnHTMLOutputElementKeyPress(handler func(HTMLOutputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLPElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// PState returns the cached snapshot for the <p> element ref.
func (ref *ElementRef[HTMLPElement]) PState() HTMLPElementState {
	if ref == nil {
		return HTMLPElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLPElementState); ok {
		return raw
	}
	return HTMLPElementState{}
}

func (ref *ElementRef[HTMLPElement]) dispatchHTMLPElementEvent(event string, snapshot HTMLPElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLPElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLPElementState(prev HTMLPElementState, payload map[string]any) HTMLPElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLPElementDefaults(ref *ElementRef[HTMLPElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PState()
			next := buildHTMLPElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLPElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementFocus(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLPElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementBlur(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLPElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementClick(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLPElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementDoubleClick(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLPElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementContextMenu(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLPElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementPointerDown(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLPElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementPointerUp(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLPElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementPointerMove(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLPElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementPointerEnter(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLPElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementPointerLeave(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLPElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementPointerOver(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLPElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementPointerOut(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLPElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementPointerCancel(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLPElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementWheel(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLPElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementKeyDown(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLPElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementKeyUp(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLPElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLPElement]) OnHTMLPElementKeyPress(handler func(HTMLPElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLParamElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// ParamState returns the cached snapshot for the <param> element ref.
func (ref *ElementRef[HTMLParamElement]) ParamState() HTMLParamElementState {
	if ref == nil {
		return HTMLParamElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLParamElementState); ok {
		return raw
	}
	return HTMLParamElementState{}
}

func (ref *ElementRef[HTMLParamElement]) dispatchHTMLParamElementEvent(event string, snapshot HTMLParamElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLParamElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLParamElementState(prev HTMLParamElementState, payload map[string]any) HTMLParamElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLParamElementDefaults(ref *ElementRef[HTMLParamElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ParamState()
			next := buildHTMLParamElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLParamElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLParamElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementFocus(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLParamElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementBlur(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLParamElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementClick(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLParamElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementDoubleClick(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLParamElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementContextMenu(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLParamElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementPointerDown(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLParamElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementPointerUp(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLParamElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementPointerMove(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLParamElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementPointerEnter(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLParamElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementPointerLeave(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLParamElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementPointerOver(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLParamElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementPointerOut(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLParamElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementPointerCancel(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLParamElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementWheel(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLParamElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementKeyDown(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLParamElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementKeyUp(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLParamElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLParamElement]) OnHTMLParamElementKeyPress(handler func(HTMLParamElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGPathElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// PathState returns the cached snapshot for the <path> element ref.
func (ref *ElementRef[SVGPathElement]) PathState() SVGPathElementState {
	if ref == nil {
		return SVGPathElementState{}
	}
	if raw, ok := ref.CachedState().(SVGPathElementState); ok {
		return raw
	}
	return SVGPathElementState{}
}

func (ref *ElementRef[SVGPathElement]) dispatchSVGPathElementEvent(event string, snapshot SVGPathElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGPathElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGPathElementState(prev SVGPathElementState, payload map[string]any) SVGPathElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGPathElementDefaults(ref *ElementRef[SVGPathElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PathState()
			next := buildSVGPathElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPathElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGPathElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementFocus(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGPathElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementBlur(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGPathElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementClick(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGPathElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementDoubleClick(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGPathElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementContextMenu(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGPathElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementPointerDown(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGPathElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementPointerUp(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGPathElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementPointerMove(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGPathElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementPointerEnter(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGPathElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementPointerLeave(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGPathElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementPointerOver(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGPathElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementPointerOut(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGPathElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementPointerCancel(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGPathElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementWheel(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGPathElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementKeyDown(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGPathElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementKeyUp(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGPathElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGPathElement]) OnSVGPathElementKeyPress(handler func(SVGPathElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGPatternElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// PatternState returns the cached snapshot for the <pattern> element ref.
func (ref *ElementRef[SVGPatternElement]) PatternState() SVGPatternElementState {
	if ref == nil {
		return SVGPatternElementState{}
	}
	if raw, ok := ref.CachedState().(SVGPatternElementState); ok {
		return raw
	}
	return SVGPatternElementState{}
}

func (ref *ElementRef[SVGPatternElement]) dispatchSVGPatternElementEvent(event string, snapshot SVGPatternElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGPatternElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGPatternElementState(prev SVGPatternElementState, payload map[string]any) SVGPatternElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGPatternElementDefaults(ref *ElementRef[SVGPatternElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PatternState()
			next := buildSVGPatternElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPatternElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGPatternElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementFocus(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGPatternElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementBlur(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGPatternElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementClick(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGPatternElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementDoubleClick(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGPatternElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementContextMenu(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGPatternElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementPointerDown(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGPatternElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementPointerUp(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGPatternElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementPointerMove(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGPatternElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementPointerEnter(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGPatternElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementPointerLeave(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGPatternElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementPointerOver(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGPatternElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementPointerOut(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGPatternElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementPointerCancel(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGPatternElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementWheel(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGPatternElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementKeyDown(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGPatternElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementKeyUp(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGPatternElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGPatternElement]) OnSVGPatternElementKeyPress(handler func(SVGPatternElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLPictureElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// PictureState returns the cached snapshot for the <picture> element ref.
func (ref *ElementRef[HTMLPictureElement]) PictureState() HTMLPictureElementState {
	if ref == nil {
		return HTMLPictureElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLPictureElementState); ok {
		return raw
	}
	return HTMLPictureElementState{}
}

func (ref *ElementRef[HTMLPictureElement]) dispatchHTMLPictureElementEvent(event string, snapshot HTMLPictureElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLPictureElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLPictureElementState(prev HTMLPictureElementState, payload map[string]any) HTMLPictureElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLPictureElementDefaults(ref *ElementRef[HTMLPictureElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PictureState()
			next := buildHTMLPictureElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPictureElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLPictureElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementFocus(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLPictureElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementBlur(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLPictureElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementClick(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLPictureElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementDoubleClick(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLPictureElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementContextMenu(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLPictureElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementPointerDown(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLPictureElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementPointerUp(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLPictureElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementPointerMove(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLPictureElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementPointerEnter(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLPictureElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementPointerLeave(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLPictureElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementPointerOver(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLPictureElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementPointerOut(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLPictureElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementPointerCancel(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLPictureElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementWheel(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLPictureElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementKeyDown(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLPictureElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementKeyUp(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLPictureElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLPictureElement]) OnHTMLPictureElementKeyPress(handler func(HTMLPictureElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGPolygonElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// PolygonState returns the cached snapshot for the <polygon> element ref.
func (ref *ElementRef[SVGPolygonElement]) PolygonState() SVGPolygonElementState {
	if ref == nil {
		return SVGPolygonElementState{}
	}
	if raw, ok := ref.CachedState().(SVGPolygonElementState); ok {
		return raw
	}
	return SVGPolygonElementState{}
}

func (ref *ElementRef[SVGPolygonElement]) dispatchSVGPolygonElementEvent(event string, snapshot SVGPolygonElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGPolygonElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGPolygonElementState(prev SVGPolygonElementState, payload map[string]any) SVGPolygonElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGPolygonElementDefaults(ref *ElementRef[SVGPolygonElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolygonState()
			next := buildSVGPolygonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolygonElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGPolygonElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementFocus(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGPolygonElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementBlur(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGPolygonElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementClick(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGPolygonElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementDoubleClick(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGPolygonElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementContextMenu(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGPolygonElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementPointerDown(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGPolygonElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementPointerUp(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGPolygonElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementPointerMove(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGPolygonElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementPointerEnter(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGPolygonElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementPointerLeave(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGPolygonElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementPointerOver(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGPolygonElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementPointerOut(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGPolygonElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementPointerCancel(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGPolygonElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementWheel(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGPolygonElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementKeyDown(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGPolygonElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementKeyUp(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGPolygonElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGPolygonElement]) OnSVGPolygonElementKeyPress(handler func(SVGPolygonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGPolylineElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// PolylineState returns the cached snapshot for the <polyline> element ref.
func (ref *ElementRef[SVGPolylineElement]) PolylineState() SVGPolylineElementState {
	if ref == nil {
		return SVGPolylineElementState{}
	}
	if raw, ok := ref.CachedState().(SVGPolylineElementState); ok {
		return raw
	}
	return SVGPolylineElementState{}
}

func (ref *ElementRef[SVGPolylineElement]) dispatchSVGPolylineElementEvent(event string, snapshot SVGPolylineElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGPolylineElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGPolylineElementState(prev SVGPolylineElementState, payload map[string]any) SVGPolylineElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGPolylineElementDefaults(ref *ElementRef[SVGPolylineElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PolylineState()
			next := buildSVGPolylineElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGPolylineElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGPolylineElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementFocus(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGPolylineElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementBlur(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGPolylineElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementClick(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGPolylineElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementDoubleClick(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGPolylineElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementContextMenu(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGPolylineElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementPointerDown(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGPolylineElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementPointerUp(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGPolylineElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementPointerMove(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGPolylineElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementPointerEnter(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGPolylineElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementPointerLeave(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGPolylineElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementPointerOver(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGPolylineElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementPointerOut(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGPolylineElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementPointerCancel(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGPolylineElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementWheel(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGPolylineElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementKeyDown(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGPolylineElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementKeyUp(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGPolylineElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGPolylineElement]) OnSVGPolylineElementKeyPress(handler func(SVGPolylineElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLPortalElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// PortalState returns the cached snapshot for the <portal> element ref.
func (ref *ElementRef[HTMLPortalElement]) PortalState() HTMLPortalElementState {
	if ref == nil {
		return HTMLPortalElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLPortalElementState); ok {
		return raw
	}
	return HTMLPortalElementState{}
}

func (ref *ElementRef[HTMLPortalElement]) dispatchHTMLPortalElementEvent(event string, snapshot HTMLPortalElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLPortalElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLPortalElementState(prev HTMLPortalElementState, payload map[string]any) HTMLPortalElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLPortalElementDefaults(ref *ElementRef[HTMLPortalElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PortalState()
			next := buildHTMLPortalElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPortalElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLPortalElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementFocus(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLPortalElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementBlur(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLPortalElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementClick(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLPortalElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementDoubleClick(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLPortalElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementContextMenu(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLPortalElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementPointerDown(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLPortalElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementPointerUp(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLPortalElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementPointerMove(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLPortalElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementPointerEnter(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLPortalElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementPointerLeave(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLPortalElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementPointerOver(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLPortalElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementPointerOut(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLPortalElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementPointerCancel(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLPortalElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementWheel(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLPortalElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementKeyDown(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLPortalElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementKeyUp(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLPortalElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLPortalElement]) OnHTMLPortalElementKeyPress(handler func(HTMLPortalElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLPreElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// PreState returns the cached snapshot for the <pre> element ref.
func (ref *ElementRef[HTMLPreElement]) PreState() HTMLPreElementState {
	if ref == nil {
		return HTMLPreElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLPreElementState); ok {
		return raw
	}
	return HTMLPreElementState{}
}

func (ref *ElementRef[HTMLPreElement]) dispatchHTMLPreElementEvent(event string, snapshot HTMLPreElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLPreElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLPreElementState(prev HTMLPreElementState, payload map[string]any) HTMLPreElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLPreElementDefaults(ref *ElementRef[HTMLPreElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.PreState()
			next := buildHTMLPreElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLPreElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLPreElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementFocus(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLPreElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementBlur(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLPreElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementClick(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLPreElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementDoubleClick(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLPreElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementContextMenu(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLPreElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementPointerDown(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLPreElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementPointerUp(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLPreElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementPointerMove(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLPreElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementPointerEnter(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLPreElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementPointerLeave(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLPreElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementPointerOver(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLPreElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementPointerOut(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLPreElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementPointerCancel(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLPreElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementWheel(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLPreElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementKeyDown(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLPreElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementKeyUp(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLPreElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLPreElement]) OnHTMLPreElementKeyPress(handler func(HTMLPreElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLProgressElementState struct {
	HTMLElementState
	HTMLKeyboardState
	Value    float64
	Max      float64
	Position float64
}

// ProgressState returns the cached snapshot for the <progress> element ref.
func (ref *ElementRef[HTMLProgressElement]) ProgressState() HTMLProgressElementState {
	if ref == nil {
		return HTMLProgressElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLProgressElementState); ok {
		return raw
	}
	return HTMLProgressElementState{}
}

func (ref *ElementRef[HTMLProgressElement]) dispatchHTMLProgressElementEvent(event string, snapshot HTMLProgressElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLProgressElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLProgressElementState(prev HTMLProgressElementState, payload map[string]any) HTMLProgressElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	next.Value = payloadFloat(payload, "target.value", prev.Value)
	next.Max = payloadFloat(payload, "target.max", prev.Max)
	next.Position = payloadFloat(payload, "target.position", prev.Position)
	return next
}

func applyHTMLProgressElementDefaults(ref *ElementRef[HTMLProgressElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("change", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("change"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "change")
		ref.Bind("change", binding)
	}
}

// OnHTMLProgressElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementFocus(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLProgressElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementBlur(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLProgressElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementClick(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLProgressElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementDoubleClick(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLProgressElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementContextMenu(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLProgressElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementPointerDown(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLProgressElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementPointerUp(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLProgressElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementPointerMove(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLProgressElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementPointerEnter(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLProgressElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementPointerLeave(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLProgressElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementPointerOver(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLProgressElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementPointerOut(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLProgressElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementPointerCancel(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLProgressElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementWheel(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLProgressElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementKeyDown(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLProgressElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementKeyUp(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLProgressElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLProgressElement]) OnHTMLProgressElementKeyPress(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnProgressChange registers a handler for the "change" event.
func (ref *ElementRef[HTMLProgressElement]) OnProgressChange(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("change", handler)
}

type HTMLQElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// QState returns the cached snapshot for the <q> element ref.
func (ref *ElementRef[HTMLQElement]) QState() HTMLQElementState {
	if ref == nil {
		return HTMLQElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLQElementState); ok {
		return raw
	}
	return HTMLQElementState{}
}

func (ref *ElementRef[HTMLQElement]) dispatchHTMLQElementEvent(event string, snapshot HTMLQElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLQElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLQElementState(prev HTMLQElementState, payload map[string]any) HTMLQElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLQElementDefaults(ref *ElementRef[HTMLQElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.QState()
			next := buildHTMLQElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLQElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLQElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementFocus(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLQElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementBlur(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLQElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementClick(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLQElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementDoubleClick(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLQElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementContextMenu(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLQElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementPointerDown(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLQElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementPointerUp(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLQElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementPointerMove(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLQElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementPointerEnter(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLQElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementPointerLeave(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLQElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementPointerOver(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLQElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementPointerOut(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLQElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementPointerCancel(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLQElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementWheel(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLQElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementKeyDown(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLQElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementKeyUp(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLQElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLQElement]) OnHTMLQElementKeyPress(handler func(HTMLQElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGRadialGradientElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// RadialGradientState returns the cached snapshot for the <radialGradient> element ref.
func (ref *ElementRef[SVGRadialGradientElement]) RadialGradientState() SVGRadialGradientElementState {
	if ref == nil {
		return SVGRadialGradientElementState{}
	}
	if raw, ok := ref.CachedState().(SVGRadialGradientElementState); ok {
		return raw
	}
	return SVGRadialGradientElementState{}
}

func (ref *ElementRef[SVGRadialGradientElement]) dispatchSVGRadialGradientElementEvent(event string, snapshot SVGRadialGradientElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGRadialGradientElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGRadialGradientElementState(prev SVGRadialGradientElementState, payload map[string]any) SVGRadialGradientElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGRadialGradientElementDefaults(ref *ElementRef[SVGRadialGradientElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RadialGradientState()
			next := buildSVGRadialGradientElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRadialGradientElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGRadialGradientElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementFocus(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGRadialGradientElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementBlur(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGRadialGradientElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementClick(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGRadialGradientElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementDoubleClick(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGRadialGradientElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementContextMenu(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGRadialGradientElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementPointerDown(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGRadialGradientElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementPointerUp(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGRadialGradientElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementPointerMove(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGRadialGradientElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementPointerEnter(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGRadialGradientElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementPointerLeave(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGRadialGradientElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementPointerOver(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGRadialGradientElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementPointerOut(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGRadialGradientElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementPointerCancel(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGRadialGradientElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementWheel(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGRadialGradientElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementKeyDown(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGRadialGradientElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementKeyUp(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGRadialGradientElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGRadialGradientElement]) OnSVGRadialGradientElementKeyPress(handler func(SVGRadialGradientElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLRbElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// RbState returns the cached snapshot for the <rb> element ref.
func (ref *ElementRef[HTMLRbElement]) RbState() HTMLRbElementState {
	if ref == nil {
		return HTMLRbElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLRbElementState); ok {
		return raw
	}
	return HTMLRbElementState{}
}

func (ref *ElementRef[HTMLRbElement]) dispatchHTMLRbElementEvent(event string, snapshot HTMLRbElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLRbElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLRbElementState(prev HTMLRbElementState, payload map[string]any) HTMLRbElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLRbElementDefaults(ref *ElementRef[HTMLRbElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RbState()
			next := buildHTMLRbElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRbElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLRbElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementFocus(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLRbElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementBlur(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLRbElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementClick(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLRbElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementDoubleClick(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLRbElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementContextMenu(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLRbElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementPointerDown(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLRbElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementPointerUp(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLRbElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementPointerMove(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLRbElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementPointerEnter(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLRbElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementPointerLeave(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLRbElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementPointerOver(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLRbElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementPointerOut(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLRbElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementPointerCancel(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLRbElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementWheel(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLRbElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementKeyDown(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLRbElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementKeyUp(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLRbElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLRbElement]) OnHTMLRbElementKeyPress(handler func(HTMLRbElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGRectElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// RectState returns the cached snapshot for the <rect> element ref.
func (ref *ElementRef[SVGRectElement]) RectState() SVGRectElementState {
	if ref == nil {
		return SVGRectElementState{}
	}
	if raw, ok := ref.CachedState().(SVGRectElementState); ok {
		return raw
	}
	return SVGRectElementState{}
}

func (ref *ElementRef[SVGRectElement]) dispatchSVGRectElementEvent(event string, snapshot SVGRectElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGRectElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGRectElementState(prev SVGRectElementState, payload map[string]any) SVGRectElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGRectElementDefaults(ref *ElementRef[SVGRectElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RectState()
			next := buildSVGRectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGRectElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGRectElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementFocus(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGRectElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementBlur(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGRectElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementClick(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGRectElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementDoubleClick(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGRectElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementContextMenu(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGRectElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementPointerDown(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGRectElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementPointerUp(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGRectElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementPointerMove(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGRectElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementPointerEnter(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGRectElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementPointerLeave(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGRectElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementPointerOver(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGRectElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementPointerOut(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGRectElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementPointerCancel(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGRectElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementWheel(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGRectElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementKeyDown(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGRectElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementKeyUp(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGRectElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGRectElement]) OnSVGRectElementKeyPress(handler func(SVGRectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLRpElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// RpState returns the cached snapshot for the <rp> element ref.
func (ref *ElementRef[HTMLRpElement]) RpState() HTMLRpElementState {
	if ref == nil {
		return HTMLRpElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLRpElementState); ok {
		return raw
	}
	return HTMLRpElementState{}
}

func (ref *ElementRef[HTMLRpElement]) dispatchHTMLRpElementEvent(event string, snapshot HTMLRpElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLRpElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLRpElementState(prev HTMLRpElementState, payload map[string]any) HTMLRpElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLRpElementDefaults(ref *ElementRef[HTMLRpElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RpState()
			next := buildHTMLRpElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRpElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLRpElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementFocus(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLRpElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementBlur(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLRpElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementClick(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLRpElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementDoubleClick(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLRpElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementContextMenu(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLRpElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementPointerDown(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLRpElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementPointerUp(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLRpElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementPointerMove(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLRpElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementPointerEnter(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLRpElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementPointerLeave(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLRpElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementPointerOver(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLRpElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementPointerOut(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLRpElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementPointerCancel(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLRpElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementWheel(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLRpElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementKeyDown(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLRpElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementKeyUp(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLRpElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLRpElement]) OnHTMLRpElementKeyPress(handler func(HTMLRpElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLRtElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// RtState returns the cached snapshot for the <rt> element ref.
func (ref *ElementRef[HTMLRtElement]) RtState() HTMLRtElementState {
	if ref == nil {
		return HTMLRtElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLRtElementState); ok {
		return raw
	}
	return HTMLRtElementState{}
}

func (ref *ElementRef[HTMLRtElement]) dispatchHTMLRtElementEvent(event string, snapshot HTMLRtElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLRtElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLRtElementState(prev HTMLRtElementState, payload map[string]any) HTMLRtElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLRtElementDefaults(ref *ElementRef[HTMLRtElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtState()
			next := buildHTMLRtElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLRtElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementFocus(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLRtElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementBlur(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLRtElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementClick(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLRtElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementDoubleClick(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLRtElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementContextMenu(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLRtElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementPointerDown(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLRtElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementPointerUp(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLRtElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementPointerMove(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLRtElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementPointerEnter(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLRtElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementPointerLeave(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLRtElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementPointerOver(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLRtElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementPointerOut(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLRtElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementPointerCancel(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLRtElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementWheel(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLRtElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementKeyDown(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLRtElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementKeyUp(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLRtElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLRtElement]) OnHTMLRtElementKeyPress(handler func(HTMLRtElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLRtcElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// RtcState returns the cached snapshot for the <rtc> element ref.
func (ref *ElementRef[HTMLRtcElement]) RtcState() HTMLRtcElementState {
	if ref == nil {
		return HTMLRtcElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLRtcElementState); ok {
		return raw
	}
	return HTMLRtcElementState{}
}

func (ref *ElementRef[HTMLRtcElement]) dispatchHTMLRtcElementEvent(event string, snapshot HTMLRtcElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLRtcElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLRtcElementState(prev HTMLRtcElementState, payload map[string]any) HTMLRtcElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLRtcElementDefaults(ref *ElementRef[HTMLRtcElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RtcState()
			next := buildHTMLRtcElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRtcElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLRtcElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementFocus(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLRtcElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementBlur(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLRtcElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementClick(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLRtcElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementDoubleClick(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLRtcElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementContextMenu(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLRtcElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementPointerDown(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLRtcElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementPointerUp(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLRtcElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementPointerMove(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLRtcElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementPointerEnter(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLRtcElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementPointerLeave(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLRtcElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementPointerOver(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLRtcElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementPointerOut(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLRtcElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementPointerCancel(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLRtcElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementWheel(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLRtcElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementKeyDown(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLRtcElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementKeyUp(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLRtcElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLRtcElement]) OnHTMLRtcElementKeyPress(handler func(HTMLRtcElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLRubyElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// RubyState returns the cached snapshot for the <ruby> element ref.
func (ref *ElementRef[HTMLRubyElement]) RubyState() HTMLRubyElementState {
	if ref == nil {
		return HTMLRubyElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLRubyElementState); ok {
		return raw
	}
	return HTMLRubyElementState{}
}

func (ref *ElementRef[HTMLRubyElement]) dispatchHTMLRubyElementEvent(event string, snapshot HTMLRubyElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLRubyElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLRubyElementState(prev HTMLRubyElementState, payload map[string]any) HTMLRubyElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLRubyElementDefaults(ref *ElementRef[HTMLRubyElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.RubyState()
			next := buildHTMLRubyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLRubyElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLRubyElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementFocus(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLRubyElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementBlur(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLRubyElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementClick(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLRubyElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementDoubleClick(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLRubyElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementContextMenu(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLRubyElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementPointerDown(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLRubyElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementPointerUp(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLRubyElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementPointerMove(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLRubyElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementPointerEnter(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLRubyElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementPointerLeave(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLRubyElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementPointerOver(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLRubyElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementPointerOut(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLRubyElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementPointerCancel(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLRubyElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementWheel(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLRubyElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementKeyDown(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLRubyElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementKeyUp(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLRubyElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLRubyElement]) OnHTMLRubyElementKeyPress(handler func(HTMLRubyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLSElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// SState returns the cached snapshot for the <s> element ref.
func (ref *ElementRef[HTMLSElement]) SState() HTMLSElementState {
	if ref == nil {
		return HTMLSElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSElementState); ok {
		return raw
	}
	return HTMLSElementState{}
}

func (ref *ElementRef[HTMLSElement]) dispatchHTMLSElementEvent(event string, snapshot HTMLSElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSElementState(prev HTMLSElementState, payload map[string]any) HTMLSElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLSElementDefaults(ref *ElementRef[HTMLSElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SState()
			next := buildHTMLSElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLSElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementFocus(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLSElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementBlur(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLSElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementClick(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLSElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementDoubleClick(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLSElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementContextMenu(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLSElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementPointerDown(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLSElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementPointerUp(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLSElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementPointerMove(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLSElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementPointerEnter(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLSElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementPointerLeave(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLSElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementPointerOver(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLSElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementPointerOut(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLSElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementPointerCancel(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLSElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementWheel(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLSElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementKeyDown(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLSElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementKeyUp(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLSElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLSElement]) OnHTMLSElementKeyPress(handler func(HTMLSElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLSampElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// SampState returns the cached snapshot for the <samp> element ref.
func (ref *ElementRef[HTMLSampElement]) SampState() HTMLSampElementState {
	if ref == nil {
		return HTMLSampElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSampElementState); ok {
		return raw
	}
	return HTMLSampElementState{}
}

func (ref *ElementRef[HTMLSampElement]) dispatchHTMLSampElementEvent(event string, snapshot HTMLSampElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSampElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSampElementState(prev HTMLSampElementState, payload map[string]any) HTMLSampElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLSampElementDefaults(ref *ElementRef[HTMLSampElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SampState()
			next := buildHTMLSampElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSampElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLSampElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementFocus(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLSampElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementBlur(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLSampElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementClick(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLSampElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementDoubleClick(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLSampElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementContextMenu(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLSampElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementPointerDown(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLSampElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementPointerUp(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLSampElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementPointerMove(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLSampElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementPointerEnter(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLSampElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementPointerLeave(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLSampElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementPointerOver(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLSampElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementPointerOut(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLSampElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementPointerCancel(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLSampElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementWheel(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLSampElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementKeyDown(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLSampElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementKeyUp(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLSampElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLSampElement]) OnHTMLSampElementKeyPress(handler func(HTMLSampElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLScriptElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// ScriptState returns the cached snapshot for the <script> element ref.
func (ref *ElementRef[HTMLScriptElement]) ScriptState() HTMLScriptElementState {
	if ref == nil {
		return HTMLScriptElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLScriptElementState); ok {
		return raw
	}
	return HTMLScriptElementState{}
}

func (ref *ElementRef[HTMLScriptElement]) dispatchHTMLScriptElementEvent(event string, snapshot HTMLScriptElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLScriptElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLScriptElementState(prev HTMLScriptElementState, payload map[string]any) HTMLScriptElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLScriptElementDefaults(ref *ElementRef[HTMLScriptElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ScriptState()
			next := buildHTMLScriptElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLScriptElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLScriptElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementFocus(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLScriptElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementBlur(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLScriptElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementClick(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLScriptElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementDoubleClick(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLScriptElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementContextMenu(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLScriptElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementPointerDown(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLScriptElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementPointerUp(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLScriptElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementPointerMove(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLScriptElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementPointerEnter(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLScriptElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementPointerLeave(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLScriptElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementPointerOver(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLScriptElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementPointerOut(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLScriptElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementPointerCancel(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLScriptElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementWheel(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLScriptElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementKeyDown(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLScriptElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementKeyUp(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLScriptElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLScriptElement]) OnHTMLScriptElementKeyPress(handler func(HTMLScriptElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLSectionElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// SectionState returns the cached snapshot for the <section> element ref.
func (ref *ElementRef[HTMLSectionElement]) SectionState() HTMLSectionElementState {
	if ref == nil {
		return HTMLSectionElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSectionElementState); ok {
		return raw
	}
	return HTMLSectionElementState{}
}

func (ref *ElementRef[HTMLSectionElement]) dispatchHTMLSectionElementEvent(event string, snapshot HTMLSectionElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSectionElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSectionElementState(prev HTMLSectionElementState, payload map[string]any) HTMLSectionElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLSectionElementDefaults(ref *ElementRef[HTMLSectionElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SectionState()
			next := buildHTMLSectionElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSectionElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLSectionElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementFocus(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLSectionElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementBlur(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLSectionElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementClick(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLSectionElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementDoubleClick(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLSectionElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementContextMenu(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLSectionElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementPointerDown(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLSectionElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementPointerUp(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLSectionElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementPointerMove(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLSectionElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementPointerEnter(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLSectionElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementPointerLeave(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLSectionElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementPointerOver(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLSectionElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementPointerOut(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLSectionElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementPointerCancel(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLSectionElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementWheel(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLSectionElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementKeyDown(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLSectionElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementKeyUp(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLSectionElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLSectionElement]) OnHTMLSectionElementKeyPress(handler func(HTMLSectionElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLSelectElementState struct {
	HTMLElementState
	HTMLKeyboardState
	Value         string
	SelectedIndex int
	Length        int
	Multiple      bool
}

// SelectState returns the cached snapshot for the <select> element ref.
func (ref *ElementRef[HTMLSelectElement]) SelectState() HTMLSelectElementState {
	if ref == nil {
		return HTMLSelectElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSelectElementState); ok {
		return raw
	}
	return HTMLSelectElementState{}
}

func (ref *ElementRef[HTMLSelectElement]) dispatchHTMLSelectElementEvent(event string, snapshot HTMLSelectElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSelectElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSelectElementState(prev HTMLSelectElementState, payload map[string]any) HTMLSelectElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	next.Value = payloadString(payload, "target.value", prev.Value)
	next.SelectedIndex = payloadInt(payload, "target.selectedIndex", prev.SelectedIndex)
	next.Length = payloadInt(payload, "target.length", prev.Length)
	next.Multiple = payloadBool(payload, "target.multiple", prev.Multiple)
	return next
}

func applyHTMLSelectElementDefaults(ref *ElementRef[HTMLSelectElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("change", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("change"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "change")
		ref.Bind("change", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("input", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("input"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "input")
		ref.Bind("input", binding)
	}
}

// OnHTMLSelectElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementFocus(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLSelectElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementBlur(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLSelectElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementClick(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLSelectElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementDoubleClick(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLSelectElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementContextMenu(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLSelectElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementPointerDown(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLSelectElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementPointerUp(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLSelectElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementPointerMove(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLSelectElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementPointerEnter(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLSelectElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementPointerLeave(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLSelectElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementPointerOver(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLSelectElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementPointerOut(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLSelectElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementPointerCancel(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLSelectElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementWheel(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLSelectElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementKeyDown(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLSelectElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementKeyUp(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLSelectElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLSelectElement]) OnHTMLSelectElementKeyPress(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnSelectChange registers a handler for the "change" event.
func (ref *ElementRef[HTMLSelectElement]) OnSelectChange(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("change", handler)
}

// OnSelectInput registers a handler for the "input" event.
func (ref *ElementRef[HTMLSelectElement]) OnSelectInput(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("input", handler)
}

type HTMLSlotElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// SlotState returns the cached snapshot for the <slot> element ref.
func (ref *ElementRef[HTMLSlotElement]) SlotState() HTMLSlotElementState {
	if ref == nil {
		return HTMLSlotElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSlotElementState); ok {
		return raw
	}
	return HTMLSlotElementState{}
}

func (ref *ElementRef[HTMLSlotElement]) dispatchHTMLSlotElementEvent(event string, snapshot HTMLSlotElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSlotElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSlotElementState(prev HTMLSlotElementState, payload map[string]any) HTMLSlotElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLSlotElementDefaults(ref *ElementRef[HTMLSlotElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SlotState()
			next := buildHTMLSlotElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSlotElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLSlotElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementFocus(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLSlotElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementBlur(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLSlotElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementClick(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLSlotElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementDoubleClick(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLSlotElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementContextMenu(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLSlotElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementPointerDown(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLSlotElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementPointerUp(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLSlotElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementPointerMove(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLSlotElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementPointerEnter(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLSlotElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementPointerLeave(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLSlotElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementPointerOver(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLSlotElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementPointerOut(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLSlotElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementPointerCancel(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLSlotElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementWheel(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLSlotElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementKeyDown(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLSlotElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementKeyUp(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLSlotElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLSlotElement]) OnHTMLSlotElementKeyPress(handler func(HTMLSlotElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLSmallElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// SmallState returns the cached snapshot for the <small> element ref.
func (ref *ElementRef[HTMLSmallElement]) SmallState() HTMLSmallElementState {
	if ref == nil {
		return HTMLSmallElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSmallElementState); ok {
		return raw
	}
	return HTMLSmallElementState{}
}

func (ref *ElementRef[HTMLSmallElement]) dispatchHTMLSmallElementEvent(event string, snapshot HTMLSmallElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSmallElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSmallElementState(prev HTMLSmallElementState, payload map[string]any) HTMLSmallElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLSmallElementDefaults(ref *ElementRef[HTMLSmallElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SmallState()
			next := buildHTMLSmallElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSmallElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLSmallElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementFocus(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLSmallElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementBlur(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLSmallElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementClick(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLSmallElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementDoubleClick(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLSmallElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementContextMenu(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLSmallElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementPointerDown(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLSmallElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementPointerUp(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLSmallElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementPointerMove(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLSmallElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementPointerEnter(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLSmallElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementPointerLeave(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLSmallElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementPointerOver(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLSmallElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementPointerOut(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLSmallElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementPointerCancel(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLSmallElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementWheel(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLSmallElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementKeyDown(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLSmallElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementKeyUp(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLSmallElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLSmallElement]) OnHTMLSmallElementKeyPress(handler func(HTMLSmallElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLSourceElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// SourceState returns the cached snapshot for the <source> element ref.
func (ref *ElementRef[HTMLSourceElement]) SourceState() HTMLSourceElementState {
	if ref == nil {
		return HTMLSourceElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSourceElementState); ok {
		return raw
	}
	return HTMLSourceElementState{}
}

func (ref *ElementRef[HTMLSourceElement]) dispatchHTMLSourceElementEvent(event string, snapshot HTMLSourceElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSourceElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSourceElementState(prev HTMLSourceElementState, payload map[string]any) HTMLSourceElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLSourceElementDefaults(ref *ElementRef[HTMLSourceElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SourceState()
			next := buildHTMLSourceElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSourceElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLSourceElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementFocus(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLSourceElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementBlur(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLSourceElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementClick(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLSourceElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementDoubleClick(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLSourceElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementContextMenu(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLSourceElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementPointerDown(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLSourceElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementPointerUp(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLSourceElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementPointerMove(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLSourceElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementPointerEnter(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLSourceElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementPointerLeave(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLSourceElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementPointerOver(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLSourceElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementPointerOut(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLSourceElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementPointerCancel(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLSourceElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementWheel(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLSourceElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementKeyDown(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLSourceElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementKeyUp(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLSourceElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLSourceElement]) OnHTMLSourceElementKeyPress(handler func(HTMLSourceElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLSpanElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// SpanState returns the cached snapshot for the <span> element ref.
func (ref *ElementRef[HTMLSpanElement]) SpanState() HTMLSpanElementState {
	if ref == nil {
		return HTMLSpanElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSpanElementState); ok {
		return raw
	}
	return HTMLSpanElementState{}
}

func (ref *ElementRef[HTMLSpanElement]) dispatchHTMLSpanElementEvent(event string, snapshot HTMLSpanElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSpanElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSpanElementState(prev HTMLSpanElementState, payload map[string]any) HTMLSpanElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLSpanElementDefaults(ref *ElementRef[HTMLSpanElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SpanState()
			next := buildHTMLSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSpanElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLSpanElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementFocus(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLSpanElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementBlur(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLSpanElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementClick(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLSpanElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementDoubleClick(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLSpanElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementContextMenu(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLSpanElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementPointerDown(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLSpanElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementPointerUp(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLSpanElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementPointerMove(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLSpanElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementPointerEnter(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLSpanElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementPointerLeave(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLSpanElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementPointerOver(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLSpanElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementPointerOut(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLSpanElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementPointerCancel(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLSpanElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementWheel(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLSpanElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementKeyDown(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLSpanElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementKeyUp(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLSpanElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLSpanElement]) OnHTMLSpanElementKeyPress(handler func(HTMLSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGStopElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// StopState returns the cached snapshot for the <stop> element ref.
func (ref *ElementRef[SVGStopElement]) StopState() SVGStopElementState {
	if ref == nil {
		return SVGStopElementState{}
	}
	if raw, ok := ref.CachedState().(SVGStopElementState); ok {
		return raw
	}
	return SVGStopElementState{}
}

func (ref *ElementRef[SVGStopElement]) dispatchSVGStopElementEvent(event string, snapshot SVGStopElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGStopElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGStopElementState(prev SVGStopElementState, payload map[string]any) SVGStopElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGStopElementDefaults(ref *ElementRef[SVGStopElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StopState()
			next := buildSVGStopElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGStopElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGStopElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementFocus(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGStopElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementBlur(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGStopElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementClick(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGStopElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementDoubleClick(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGStopElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementContextMenu(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGStopElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementPointerDown(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGStopElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementPointerUp(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGStopElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementPointerMove(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGStopElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementPointerEnter(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGStopElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementPointerLeave(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGStopElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementPointerOver(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGStopElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementPointerOut(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGStopElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementPointerCancel(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGStopElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementWheel(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGStopElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementKeyDown(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGStopElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementKeyUp(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGStopElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGStopElement]) OnSVGStopElementKeyPress(handler func(SVGStopElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLStrongElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// StrongState returns the cached snapshot for the <strong> element ref.
func (ref *ElementRef[HTMLStrongElement]) StrongState() HTMLStrongElementState {
	if ref == nil {
		return HTMLStrongElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLStrongElementState); ok {
		return raw
	}
	return HTMLStrongElementState{}
}

func (ref *ElementRef[HTMLStrongElement]) dispatchHTMLStrongElementEvent(event string, snapshot HTMLStrongElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLStrongElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLStrongElementState(prev HTMLStrongElementState, payload map[string]any) HTMLStrongElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLStrongElementDefaults(ref *ElementRef[HTMLStrongElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StrongState()
			next := buildHTMLStrongElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStrongElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLStrongElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementFocus(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLStrongElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementBlur(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLStrongElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementClick(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLStrongElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementDoubleClick(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLStrongElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementContextMenu(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLStrongElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementPointerDown(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLStrongElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementPointerUp(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLStrongElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementPointerMove(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLStrongElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementPointerEnter(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLStrongElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementPointerLeave(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLStrongElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementPointerOver(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLStrongElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementPointerOut(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLStrongElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementPointerCancel(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLStrongElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementWheel(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLStrongElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementKeyDown(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLStrongElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementKeyUp(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLStrongElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLStrongElement]) OnHTMLStrongElementKeyPress(handler func(HTMLStrongElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLStyleElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// StyleElState returns the cached snapshot for the <style> element ref.
func (ref *ElementRef[HTMLStyleElement]) StyleElState() HTMLStyleElementState {
	if ref == nil {
		return HTMLStyleElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLStyleElementState); ok {
		return raw
	}
	return HTMLStyleElementState{}
}

func (ref *ElementRef[HTMLStyleElement]) dispatchHTMLStyleElementEvent(event string, snapshot HTMLStyleElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLStyleElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLStyleElementState(prev HTMLStyleElementState, payload map[string]any) HTMLStyleElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLStyleElementDefaults(ref *ElementRef[HTMLStyleElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.StyleElState()
			next := buildHTMLStyleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLStyleElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLStyleElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementFocus(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLStyleElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementBlur(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLStyleElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementClick(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLStyleElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementDoubleClick(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLStyleElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementContextMenu(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLStyleElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementPointerDown(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLStyleElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementPointerUp(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLStyleElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementPointerMove(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLStyleElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementPointerEnter(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLStyleElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementPointerLeave(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLStyleElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementPointerOver(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLStyleElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementPointerOut(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLStyleElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementPointerCancel(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLStyleElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementWheel(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLStyleElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementKeyDown(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLStyleElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementKeyUp(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLStyleElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLStyleElement]) OnHTMLStyleElementKeyPress(handler func(HTMLStyleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLSubElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// SubState returns the cached snapshot for the <sub> element ref.
func (ref *ElementRef[HTMLSubElement]) SubState() HTMLSubElementState {
	if ref == nil {
		return HTMLSubElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSubElementState); ok {
		return raw
	}
	return HTMLSubElementState{}
}

func (ref *ElementRef[HTMLSubElement]) dispatchHTMLSubElementEvent(event string, snapshot HTMLSubElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSubElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSubElementState(prev HTMLSubElementState, payload map[string]any) HTMLSubElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLSubElementDefaults(ref *ElementRef[HTMLSubElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SubState()
			next := buildHTMLSubElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSubElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLSubElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementFocus(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLSubElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementBlur(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLSubElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementClick(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLSubElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementDoubleClick(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLSubElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementContextMenu(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLSubElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementPointerDown(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLSubElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementPointerUp(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLSubElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementPointerMove(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLSubElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementPointerEnter(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLSubElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementPointerLeave(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLSubElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementPointerOver(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLSubElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementPointerOut(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLSubElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementPointerCancel(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLSubElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementWheel(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLSubElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementKeyDown(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLSubElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementKeyUp(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLSubElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLSubElement]) OnHTMLSubElementKeyPress(handler func(HTMLSubElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLSummaryElementState struct {
	HTMLElementState
	HTMLKeyboardState
	Detail int
}

// SummaryState returns the cached snapshot for the <summary> element ref.
func (ref *ElementRef[HTMLSummaryElement]) SummaryState() HTMLSummaryElementState {
	if ref == nil {
		return HTMLSummaryElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSummaryElementState); ok {
		return raw
	}
	return HTMLSummaryElementState{}
}

func (ref *ElementRef[HTMLSummaryElement]) dispatchHTMLSummaryElementEvent(event string, snapshot HTMLSummaryElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSummaryElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSummaryElementState(prev HTMLSummaryElementState, payload map[string]any) HTMLSummaryElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	next.Detail = payloadInt(payload, "event.detail", prev.Detail)
	return next
}

func applyHTMLSummaryElementDefaults(ref *ElementRef[HTMLSummaryElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLSummaryElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementFocus(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLSummaryElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementBlur(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLSummaryElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementClick(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLSummaryElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementDoubleClick(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLSummaryElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementContextMenu(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLSummaryElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementPointerDown(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLSummaryElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementPointerUp(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLSummaryElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementPointerMove(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLSummaryElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementPointerEnter(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLSummaryElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementPointerLeave(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLSummaryElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementPointerOver(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLSummaryElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementPointerOut(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLSummaryElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementPointerCancel(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLSummaryElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementWheel(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLSummaryElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementKeyDown(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLSummaryElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementKeyUp(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLSummaryElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLSummaryElement]) OnHTMLSummaryElementKeyPress(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnSummaryClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSummaryElement]) OnSummaryClick(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSummaryKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSummaryElement]) OnSummaryKeyDown(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

type HTMLSupElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// SupState returns the cached snapshot for the <sup> element ref.
func (ref *ElementRef[HTMLSupElement]) SupState() HTMLSupElementState {
	if ref == nil {
		return HTMLSupElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSupElementState); ok {
		return raw
	}
	return HTMLSupElementState{}
}

func (ref *ElementRef[HTMLSupElement]) dispatchHTMLSupElementEvent(event string, snapshot HTMLSupElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSupElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSupElementState(prev HTMLSupElementState, payload map[string]any) HTMLSupElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLSupElementDefaults(ref *ElementRef[HTMLSupElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SupState()
			next := buildHTMLSupElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSupElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLSupElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementFocus(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLSupElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementBlur(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLSupElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementClick(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLSupElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementDoubleClick(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLSupElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementContextMenu(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLSupElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementPointerDown(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLSupElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementPointerUp(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLSupElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementPointerMove(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLSupElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementPointerEnter(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLSupElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementPointerLeave(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLSupElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementPointerOver(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLSupElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementPointerOut(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLSupElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementPointerCancel(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLSupElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementWheel(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLSupElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementKeyDown(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLSupElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementKeyUp(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLSupElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLSupElement]) OnHTMLSupElementKeyPress(handler func(HTMLSupElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGSvgElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// SvgState returns the cached snapshot for the <svg> element ref.
func (ref *ElementRef[SVGSvgElement]) SvgState() SVGSvgElementState {
	if ref == nil {
		return SVGSvgElementState{}
	}
	if raw, ok := ref.CachedState().(SVGSvgElementState); ok {
		return raw
	}
	return SVGSvgElementState{}
}

func (ref *ElementRef[SVGSvgElement]) dispatchSVGSvgElementEvent(event string, snapshot SVGSvgElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGSvgElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGSvgElementState(prev SVGSvgElementState, payload map[string]any) SVGSvgElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGSvgElementDefaults(ref *ElementRef[SVGSvgElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgState()
			next := buildSVGSvgElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGSvgElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementFocus(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGSvgElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementBlur(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGSvgElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementClick(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGSvgElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementDoubleClick(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGSvgElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementContextMenu(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGSvgElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementPointerDown(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGSvgElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementPointerUp(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGSvgElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementPointerMove(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGSvgElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementPointerEnter(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGSvgElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementPointerLeave(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGSvgElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementPointerOver(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGSvgElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementPointerOut(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGSvgElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementPointerCancel(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGSvgElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementWheel(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGSvgElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementKeyDown(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGSvgElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementKeyUp(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGSvgElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGSvgElement]) OnSVGSvgElementKeyPress(handler func(SVGSvgElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGSvgTextElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// SvgTextState returns the cached snapshot for the <text> element ref.
func (ref *ElementRef[SVGSvgTextElement]) SvgTextState() SVGSvgTextElementState {
	if ref == nil {
		return SVGSvgTextElementState{}
	}
	if raw, ok := ref.CachedState().(SVGSvgTextElementState); ok {
		return raw
	}
	return SVGSvgTextElementState{}
}

func (ref *ElementRef[SVGSvgTextElement]) dispatchSVGSvgTextElementEvent(event string, snapshot SVGSvgTextElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGSvgTextElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGSvgTextElementState(prev SVGSvgTextElementState, payload map[string]any) SVGSvgTextElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGSvgTextElementDefaults(ref *ElementRef[SVGSvgTextElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SvgTextState()
			next := buildSVGSvgTextElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGSvgTextElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGSvgTextElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementFocus(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGSvgTextElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementBlur(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGSvgTextElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementClick(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGSvgTextElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementDoubleClick(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGSvgTextElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementContextMenu(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGSvgTextElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementPointerDown(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGSvgTextElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementPointerUp(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGSvgTextElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementPointerMove(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGSvgTextElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementPointerEnter(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGSvgTextElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementPointerLeave(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGSvgTextElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementPointerOver(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGSvgTextElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementPointerOut(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGSvgTextElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementPointerCancel(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGSvgTextElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementWheel(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGSvgTextElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementKeyDown(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGSvgTextElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementKeyUp(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGSvgTextElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGSvgTextElement]) OnSVGSvgTextElementKeyPress(handler func(SVGSvgTextElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGTSpanElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// TSpanState returns the cached snapshot for the <tspan> element ref.
func (ref *ElementRef[SVGTSpanElement]) TSpanState() SVGTSpanElementState {
	if ref == nil {
		return SVGTSpanElementState{}
	}
	if raw, ok := ref.CachedState().(SVGTSpanElementState); ok {
		return raw
	}
	return SVGTSpanElementState{}
}

func (ref *ElementRef[SVGTSpanElement]) dispatchSVGTSpanElementEvent(event string, snapshot SVGTSpanElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGTSpanElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGTSpanElementState(prev SVGTSpanElementState, payload map[string]any) SVGTSpanElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGTSpanElementDefaults(ref *ElementRef[SVGTSpanElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TSpanState()
			next := buildSVGTSpanElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGTSpanElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGTSpanElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementFocus(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGTSpanElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementBlur(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGTSpanElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementClick(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGTSpanElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementDoubleClick(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGTSpanElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementContextMenu(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGTSpanElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementPointerDown(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGTSpanElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementPointerUp(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGTSpanElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementPointerMove(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGTSpanElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementPointerEnter(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGTSpanElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementPointerLeave(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGTSpanElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementPointerOver(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGTSpanElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementPointerOut(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGTSpanElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementPointerCancel(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGTSpanElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementWheel(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGTSpanElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementKeyDown(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGTSpanElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementKeyUp(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGTSpanElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGTSpanElement]) OnSVGTSpanElementKeyPress(handler func(SVGTSpanElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLTableElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// TableState returns the cached snapshot for the <table> element ref.
func (ref *ElementRef[HTMLTableElement]) TableState() HTMLTableElementState {
	if ref == nil {
		return HTMLTableElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLTableElementState); ok {
		return raw
	}
	return HTMLTableElementState{}
}

func (ref *ElementRef[HTMLTableElement]) dispatchHTMLTableElementEvent(event string, snapshot HTMLTableElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLTableElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLTableElementState(prev HTMLTableElementState, payload map[string]any) HTMLTableElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLTableElementDefaults(ref *ElementRef[HTMLTableElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TableState()
			next := buildHTMLTableElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTableElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLTableElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementFocus(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLTableElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementBlur(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLTableElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementClick(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLTableElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementDoubleClick(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLTableElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementContextMenu(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLTableElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementPointerDown(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLTableElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementPointerUp(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLTableElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementPointerMove(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLTableElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementPointerEnter(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLTableElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementPointerLeave(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLTableElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementPointerOver(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLTableElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementPointerOut(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLTableElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementPointerCancel(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLTableElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementWheel(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLTableElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementKeyDown(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLTableElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementKeyUp(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLTableElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLTableElement]) OnHTMLTableElementKeyPress(handler func(HTMLTableElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLTbodyElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// TbodyState returns the cached snapshot for the <tbody> element ref.
func (ref *ElementRef[HTMLTbodyElement]) TbodyState() HTMLTbodyElementState {
	if ref == nil {
		return HTMLTbodyElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLTbodyElementState); ok {
		return raw
	}
	return HTMLTbodyElementState{}
}

func (ref *ElementRef[HTMLTbodyElement]) dispatchHTMLTbodyElementEvent(event string, snapshot HTMLTbodyElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLTbodyElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLTbodyElementState(prev HTMLTbodyElementState, payload map[string]any) HTMLTbodyElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLTbodyElementDefaults(ref *ElementRef[HTMLTbodyElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TbodyState()
			next := buildHTMLTbodyElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTbodyElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLTbodyElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementFocus(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLTbodyElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementBlur(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLTbodyElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementClick(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLTbodyElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementDoubleClick(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLTbodyElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementContextMenu(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLTbodyElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementPointerDown(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLTbodyElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementPointerUp(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLTbodyElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementPointerMove(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLTbodyElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementPointerEnter(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLTbodyElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementPointerLeave(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLTbodyElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementPointerOver(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLTbodyElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementPointerOut(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLTbodyElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementPointerCancel(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLTbodyElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementWheel(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLTbodyElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementKeyDown(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLTbodyElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementKeyUp(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLTbodyElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLTbodyElement]) OnHTMLTbodyElementKeyPress(handler func(HTMLTbodyElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLTdElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// TdState returns the cached snapshot for the <td> element ref.
func (ref *ElementRef[HTMLTdElement]) TdState() HTMLTdElementState {
	if ref == nil {
		return HTMLTdElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLTdElementState); ok {
		return raw
	}
	return HTMLTdElementState{}
}

func (ref *ElementRef[HTMLTdElement]) dispatchHTMLTdElementEvent(event string, snapshot HTMLTdElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLTdElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLTdElementState(prev HTMLTdElementState, payload map[string]any) HTMLTdElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLTdElementDefaults(ref *ElementRef[HTMLTdElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TdState()
			next := buildHTMLTdElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTdElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLTdElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementFocus(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLTdElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementBlur(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLTdElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementClick(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLTdElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementDoubleClick(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLTdElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementContextMenu(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLTdElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementPointerDown(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLTdElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementPointerUp(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLTdElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementPointerMove(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLTdElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementPointerEnter(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLTdElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementPointerLeave(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLTdElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementPointerOver(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLTdElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementPointerOut(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLTdElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementPointerCancel(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLTdElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementWheel(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLTdElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementKeyDown(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLTdElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementKeyUp(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLTdElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLTdElement]) OnHTMLTdElementKeyPress(handler func(HTMLTdElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLTemplateElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// TemplateState returns the cached snapshot for the <template> element ref.
func (ref *ElementRef[HTMLTemplateElement]) TemplateState() HTMLTemplateElementState {
	if ref == nil {
		return HTMLTemplateElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLTemplateElementState); ok {
		return raw
	}
	return HTMLTemplateElementState{}
}

func (ref *ElementRef[HTMLTemplateElement]) dispatchHTMLTemplateElementEvent(event string, snapshot HTMLTemplateElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLTemplateElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLTemplateElementState(prev HTMLTemplateElementState, payload map[string]any) HTMLTemplateElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLTemplateElementDefaults(ref *ElementRef[HTMLTemplateElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TemplateState()
			next := buildHTMLTemplateElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTemplateElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLTemplateElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementFocus(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLTemplateElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementBlur(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLTemplateElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementClick(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLTemplateElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementDoubleClick(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLTemplateElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementContextMenu(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLTemplateElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementPointerDown(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLTemplateElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementPointerUp(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLTemplateElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementPointerMove(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLTemplateElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementPointerEnter(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLTemplateElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementPointerLeave(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLTemplateElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementPointerOver(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLTemplateElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementPointerOut(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLTemplateElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementPointerCancel(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLTemplateElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementWheel(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLTemplateElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementKeyDown(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLTemplateElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementKeyUp(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLTemplateElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLTemplateElement]) OnHTMLTemplateElementKeyPress(handler func(HTMLTemplateElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLTextareaElementState struct {
	HTMLElementState
	HTMLKeyboardState
	Value          string
	SelectionStart int
	SelectionEnd   int
	Rows           int
	Cols           int
	Disabled       bool
}

// TextareaState returns the cached snapshot for the <textarea> element ref.
func (ref *ElementRef[HTMLTextareaElement]) TextareaState() HTMLTextareaElementState {
	if ref == nil {
		return HTMLTextareaElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLTextareaElementState); ok {
		return raw
	}
	return HTMLTextareaElementState{}
}

func (ref *ElementRef[HTMLTextareaElement]) dispatchHTMLTextareaElementEvent(event string, snapshot HTMLTextareaElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLTextareaElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLTextareaElementState(prev HTMLTextareaElementState, payload map[string]any) HTMLTextareaElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	next.Value = payloadString(payload, "target.value", prev.Value)
	next.SelectionStart = payloadInt(payload, "target.selectionStart", prev.SelectionStart)
	next.SelectionEnd = payloadInt(payload, "target.selectionEnd", prev.SelectionEnd)
	next.Rows = payloadInt(payload, "target.rows", prev.Rows)
	next.Cols = payloadInt(payload, "target.cols", prev.Cols)
	next.Disabled = payloadBool(payload, "target.disabled", prev.Disabled)
	return next
}

func applyHTMLTextareaElementDefaults(ref *ElementRef[HTMLTextareaElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("input", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("input"), EventOptions{
			Props: []string{"event.inputType", "event.isComposing", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "input")
		ref.Bind("input", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("change", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("change"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "change")
		ref.Bind("change", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("select", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("select"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "select")
		ref.Bind("select", binding)
	}
}

// OnHTMLTextareaElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementFocus(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLTextareaElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementBlur(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLTextareaElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementClick(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLTextareaElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementDoubleClick(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLTextareaElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementContextMenu(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLTextareaElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementPointerDown(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLTextareaElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementPointerUp(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLTextareaElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementPointerMove(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLTextareaElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementPointerEnter(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLTextareaElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementPointerLeave(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLTextareaElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementPointerOver(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLTextareaElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementPointerOut(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLTextareaElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementPointerCancel(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLTextareaElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementWheel(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLTextareaElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementKeyDown(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLTextareaElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementKeyUp(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLTextareaElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLTextareaElement]) OnHTMLTextareaElementKeyPress(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnTextareaInput registers a handler for the "input" event.
func (ref *ElementRef[HTMLTextareaElement]) OnTextareaInput(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("input", handler)
}

// OnTextareaChange registers a handler for the "change" event.
func (ref *ElementRef[HTMLTextareaElement]) OnTextareaChange(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("change", handler)
}

// OnTextareaSelect registers a handler for the "select" event.
func (ref *ElementRef[HTMLTextareaElement]) OnTextareaSelect(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("select", handler)
}

type HTMLTfootElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// TfootState returns the cached snapshot for the <tfoot> element ref.
func (ref *ElementRef[HTMLTfootElement]) TfootState() HTMLTfootElementState {
	if ref == nil {
		return HTMLTfootElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLTfootElementState); ok {
		return raw
	}
	return HTMLTfootElementState{}
}

func (ref *ElementRef[HTMLTfootElement]) dispatchHTMLTfootElementEvent(event string, snapshot HTMLTfootElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLTfootElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLTfootElementState(prev HTMLTfootElementState, payload map[string]any) HTMLTfootElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLTfootElementDefaults(ref *ElementRef[HTMLTfootElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TfootState()
			next := buildHTMLTfootElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTfootElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLTfootElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementFocus(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLTfootElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementBlur(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLTfootElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementClick(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLTfootElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementDoubleClick(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLTfootElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementContextMenu(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLTfootElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementPointerDown(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLTfootElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementPointerUp(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLTfootElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementPointerMove(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLTfootElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementPointerEnter(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLTfootElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementPointerLeave(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLTfootElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementPointerOver(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLTfootElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementPointerOut(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLTfootElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementPointerCancel(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLTfootElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementWheel(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLTfootElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementKeyDown(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLTfootElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementKeyUp(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLTfootElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLTfootElement]) OnHTMLTfootElementKeyPress(handler func(HTMLTfootElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLThElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// ThState returns the cached snapshot for the <th> element ref.
func (ref *ElementRef[HTMLThElement]) ThState() HTMLThElementState {
	if ref == nil {
		return HTMLThElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLThElementState); ok {
		return raw
	}
	return HTMLThElementState{}
}

func (ref *ElementRef[HTMLThElement]) dispatchHTMLThElementEvent(event string, snapshot HTMLThElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLThElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLThElementState(prev HTMLThElementState, payload map[string]any) HTMLThElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLThElementDefaults(ref *ElementRef[HTMLThElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ThState()
			next := buildHTMLThElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLThElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLThElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementFocus(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLThElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementBlur(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLThElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementClick(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLThElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementDoubleClick(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLThElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementContextMenu(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLThElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementPointerDown(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLThElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementPointerUp(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLThElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementPointerMove(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLThElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementPointerEnter(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLThElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementPointerLeave(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLThElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementPointerOver(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLThElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementPointerOut(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLThElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementPointerCancel(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLThElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementWheel(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLThElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementKeyDown(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLThElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementKeyUp(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLThElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLThElement]) OnHTMLThElementKeyPress(handler func(HTMLThElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLTheadElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// TheadState returns the cached snapshot for the <thead> element ref.
func (ref *ElementRef[HTMLTheadElement]) TheadState() HTMLTheadElementState {
	if ref == nil {
		return HTMLTheadElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLTheadElementState); ok {
		return raw
	}
	return HTMLTheadElementState{}
}

func (ref *ElementRef[HTMLTheadElement]) dispatchHTMLTheadElementEvent(event string, snapshot HTMLTheadElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLTheadElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLTheadElementState(prev HTMLTheadElementState, payload map[string]any) HTMLTheadElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLTheadElementDefaults(ref *ElementRef[HTMLTheadElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TheadState()
			next := buildHTMLTheadElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTheadElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLTheadElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementFocus(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLTheadElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementBlur(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLTheadElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementClick(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLTheadElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementDoubleClick(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLTheadElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementContextMenu(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLTheadElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementPointerDown(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLTheadElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementPointerUp(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLTheadElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementPointerMove(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLTheadElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementPointerEnter(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLTheadElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementPointerLeave(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLTheadElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementPointerOver(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLTheadElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementPointerOut(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLTheadElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementPointerCancel(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLTheadElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementWheel(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLTheadElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementKeyDown(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLTheadElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementKeyUp(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLTheadElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLTheadElement]) OnHTMLTheadElementKeyPress(handler func(HTMLTheadElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLTimeElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// TimeState returns the cached snapshot for the <time> element ref.
func (ref *ElementRef[HTMLTimeElement]) TimeState() HTMLTimeElementState {
	if ref == nil {
		return HTMLTimeElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLTimeElementState); ok {
		return raw
	}
	return HTMLTimeElementState{}
}

func (ref *ElementRef[HTMLTimeElement]) dispatchHTMLTimeElementEvent(event string, snapshot HTMLTimeElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLTimeElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLTimeElementState(prev HTMLTimeElementState, payload map[string]any) HTMLTimeElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLTimeElementDefaults(ref *ElementRef[HTMLTimeElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TimeState()
			next := buildHTMLTimeElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTimeElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLTimeElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementFocus(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLTimeElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementBlur(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLTimeElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementClick(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLTimeElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementDoubleClick(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLTimeElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementContextMenu(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLTimeElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementPointerDown(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLTimeElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementPointerUp(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLTimeElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementPointerMove(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLTimeElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementPointerEnter(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLTimeElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementPointerLeave(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLTimeElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementPointerOver(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLTimeElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementPointerOut(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLTimeElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementPointerCancel(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLTimeElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementWheel(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLTimeElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementKeyDown(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLTimeElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementKeyUp(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLTimeElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLTimeElement]) OnHTMLTimeElementKeyPress(handler func(HTMLTimeElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLTitleElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// TitleElState returns the cached snapshot for the <title> element ref.
func (ref *ElementRef[HTMLTitleElement]) TitleElState() HTMLTitleElementState {
	if ref == nil {
		return HTMLTitleElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLTitleElementState); ok {
		return raw
	}
	return HTMLTitleElementState{}
}

func (ref *ElementRef[HTMLTitleElement]) dispatchHTMLTitleElementEvent(event string, snapshot HTMLTitleElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLTitleElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLTitleElementState(prev HTMLTitleElementState, payload map[string]any) HTMLTitleElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLTitleElementDefaults(ref *ElementRef[HTMLTitleElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TitleElState()
			next := buildHTMLTitleElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTitleElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLTitleElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementFocus(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLTitleElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementBlur(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLTitleElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementClick(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLTitleElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementDoubleClick(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLTitleElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementContextMenu(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLTitleElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementPointerDown(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLTitleElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementPointerUp(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLTitleElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementPointerMove(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLTitleElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementPointerEnter(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLTitleElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementPointerLeave(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLTitleElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementPointerOver(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLTitleElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementPointerOut(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLTitleElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementPointerCancel(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLTitleElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementWheel(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLTitleElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementKeyDown(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLTitleElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementKeyUp(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLTitleElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLTitleElement]) OnHTMLTitleElementKeyPress(handler func(HTMLTitleElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLTrElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// TrState returns the cached snapshot for the <tr> element ref.
func (ref *ElementRef[HTMLTrElement]) TrState() HTMLTrElementState {
	if ref == nil {
		return HTMLTrElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLTrElementState); ok {
		return raw
	}
	return HTMLTrElementState{}
}

func (ref *ElementRef[HTMLTrElement]) dispatchHTMLTrElementEvent(event string, snapshot HTMLTrElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLTrElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLTrElementState(prev HTMLTrElementState, payload map[string]any) HTMLTrElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLTrElementDefaults(ref *ElementRef[HTMLTrElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrState()
			next := buildHTMLTrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLTrElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementFocus(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLTrElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementBlur(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLTrElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementClick(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLTrElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementDoubleClick(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLTrElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementContextMenu(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLTrElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementPointerDown(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLTrElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementPointerUp(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLTrElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementPointerMove(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLTrElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementPointerEnter(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLTrElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementPointerLeave(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLTrElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementPointerOver(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLTrElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementPointerOut(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLTrElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementPointerCancel(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLTrElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementWheel(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLTrElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementKeyDown(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLTrElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementKeyUp(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLTrElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLTrElement]) OnHTMLTrElementKeyPress(handler func(HTMLTrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLTrackElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// TrackState returns the cached snapshot for the <track> element ref.
func (ref *ElementRef[HTMLTrackElement]) TrackState() HTMLTrackElementState {
	if ref == nil {
		return HTMLTrackElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLTrackElementState); ok {
		return raw
	}
	return HTMLTrackElementState{}
}

func (ref *ElementRef[HTMLTrackElement]) dispatchHTMLTrackElementEvent(event string, snapshot HTMLTrackElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLTrackElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLTrackElementState(prev HTMLTrackElementState, payload map[string]any) HTMLTrackElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLTrackElementDefaults(ref *ElementRef[HTMLTrackElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TrackState()
			next := buildHTMLTrackElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTrackElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLTrackElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementFocus(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLTrackElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementBlur(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLTrackElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementClick(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLTrackElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementDoubleClick(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLTrackElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementContextMenu(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLTrackElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementPointerDown(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLTrackElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementPointerUp(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLTrackElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementPointerMove(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLTrackElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementPointerEnter(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLTrackElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementPointerLeave(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLTrackElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementPointerOver(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLTrackElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementPointerOut(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLTrackElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementPointerCancel(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLTrackElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementWheel(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLTrackElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementKeyDown(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLTrackElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementKeyUp(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLTrackElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLTrackElement]) OnHTMLTrackElementKeyPress(handler func(HTMLTrackElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLUElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// UState returns the cached snapshot for the <u> element ref.
func (ref *ElementRef[HTMLUElement]) UState() HTMLUElementState {
	if ref == nil {
		return HTMLUElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLUElementState); ok {
		return raw
	}
	return HTMLUElementState{}
}

func (ref *ElementRef[HTMLUElement]) dispatchHTMLUElementEvent(event string, snapshot HTMLUElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLUElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLUElementState(prev HTMLUElementState, payload map[string]any) HTMLUElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLUElementDefaults(ref *ElementRef[HTMLUElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UState()
			next := buildHTMLUElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLUElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementFocus(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLUElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementBlur(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLUElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementClick(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLUElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementDoubleClick(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLUElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementContextMenu(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLUElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementPointerDown(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLUElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementPointerUp(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLUElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementPointerMove(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLUElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementPointerEnter(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLUElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementPointerLeave(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLUElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementPointerOver(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLUElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementPointerOut(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLUElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementPointerCancel(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLUElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementWheel(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLUElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementKeyDown(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLUElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementKeyUp(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLUElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLUElement]) OnHTMLUElementKeyPress(handler func(HTMLUElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLUlElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// UlState returns the cached snapshot for the <ul> element ref.
func (ref *ElementRef[HTMLUlElement]) UlState() HTMLUlElementState {
	if ref == nil {
		return HTMLUlElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLUlElementState); ok {
		return raw
	}
	return HTMLUlElementState{}
}

func (ref *ElementRef[HTMLUlElement]) dispatchHTMLUlElementEvent(event string, snapshot HTMLUlElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLUlElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLUlElementState(prev HTMLUlElementState, payload map[string]any) HTMLUlElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLUlElementDefaults(ref *ElementRef[HTMLUlElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UlState()
			next := buildHTMLUlElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLUlElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLUlElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementFocus(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLUlElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementBlur(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLUlElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementClick(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLUlElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementDoubleClick(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLUlElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementContextMenu(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLUlElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementPointerDown(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLUlElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementPointerUp(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLUlElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementPointerMove(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLUlElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementPointerEnter(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLUlElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementPointerLeave(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLUlElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementPointerOver(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLUlElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementPointerOut(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLUlElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementPointerCancel(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLUlElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementWheel(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLUlElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementKeyDown(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLUlElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementKeyUp(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLUlElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLUlElement]) OnHTMLUlElementKeyPress(handler func(HTMLUlElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type SVGUseElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// UseState returns the cached snapshot for the <use> element ref.
func (ref *ElementRef[SVGUseElement]) UseState() SVGUseElementState {
	if ref == nil {
		return SVGUseElementState{}
	}
	if raw, ok := ref.CachedState().(SVGUseElementState); ok {
		return raw
	}
	return SVGUseElementState{}
}

func (ref *ElementRef[SVGUseElement]) dispatchSVGUseElementEvent(event string, snapshot SVGUseElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(SVGUseElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildSVGUseElementState(prev SVGUseElementState, payload map[string]any) SVGUseElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applySVGUseElementDefaults(ref *ElementRef[SVGUseElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.UseState()
			next := buildSVGUseElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchSVGUseElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnSVGUseElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementFocus(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnSVGUseElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementBlur(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnSVGUseElementClick registers a handler for the "click" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementClick(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSVGUseElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementDoubleClick(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnSVGUseElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementContextMenu(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnSVGUseElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementPointerDown(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnSVGUseElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementPointerUp(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnSVGUseElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementPointerMove(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnSVGUseElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementPointerEnter(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnSVGUseElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementPointerLeave(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnSVGUseElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementPointerOver(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnSVGUseElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementPointerOut(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnSVGUseElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementPointerCancel(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnSVGUseElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementWheel(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnSVGUseElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementKeyDown(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnSVGUseElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementKeyUp(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnSVGUseElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[SVGUseElement]) OnSVGUseElementKeyPress(handler func(SVGUseElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLVarElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// VarState returns the cached snapshot for the <var> element ref.
func (ref *ElementRef[HTMLVarElement]) VarState() HTMLVarElementState {
	if ref == nil {
		return HTMLVarElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLVarElementState); ok {
		return raw
	}
	return HTMLVarElementState{}
}

func (ref *ElementRef[HTMLVarElement]) dispatchHTMLVarElementEvent(event string, snapshot HTMLVarElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLVarElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLVarElementState(prev HTMLVarElementState, payload map[string]any) HTMLVarElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLVarElementDefaults(ref *ElementRef[HTMLVarElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VarState()
			next := buildHTMLVarElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVarElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLVarElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementFocus(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLVarElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementBlur(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLVarElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementClick(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLVarElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementDoubleClick(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLVarElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementContextMenu(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLVarElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementPointerDown(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLVarElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementPointerUp(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLVarElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementPointerMove(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLVarElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementPointerEnter(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLVarElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementPointerLeave(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLVarElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementPointerOver(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLVarElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementPointerOut(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLVarElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementPointerCancel(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLVarElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementWheel(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLVarElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementKeyDown(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLVarElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementKeyUp(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLVarElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLVarElement]) OnHTMLVarElementKeyPress(handler func(HTMLVarElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

type HTMLVideoElementState struct {
	HTMLMediaState
	HTMLElementState
	HTMLKeyboardState
}

// VideoState returns the cached snapshot for the <video> element ref.
func (ref *ElementRef[HTMLVideoElement]) VideoState() HTMLVideoElementState {
	if ref == nil {
		return HTMLVideoElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLVideoElementState); ok {
		return raw
	}
	return HTMLVideoElementState{}
}

func (ref *ElementRef[HTMLVideoElement]) dispatchHTMLVideoElementEvent(event string, snapshot HTMLVideoElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLVideoElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLVideoElementState(prev HTMLVideoElementState, payload map[string]any) HTMLVideoElementState {
	next := prev
	next.CurrentTime = payloadFloat(payload, "target.currentTime", prev.CurrentTime)
	next.Duration = payloadFloat(payload, "target.duration", prev.Duration)
	next.Paused = payloadBool(payload, "target.paused", prev.Paused)
	next.Muted = payloadBool(payload, "target.muted", prev.Muted)
	next.Volume = payloadFloat(payload, "target.volume", prev.Volume)
	next.Seeking = payloadBool(payload, "target.seeking", prev.Seeking)
	next.Ended = payloadBool(payload, "target.ended", prev.Ended)
	next.PlaybackRate = payloadFloat(payload, "target.playbackRate", prev.PlaybackRate)
	next.ReadyState = payloadInt(payload, "target.readyState", prev.ReadyState)
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLVideoElementDefaults(ref *ElementRef[HTMLVideoElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("timeupdate", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("timeupdate"), EventOptions{
			Listen: []string{"durationchange", "play", "pause", "seeking", "seeked"},
			Props:  []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "timeupdate")
		ref.Bind("timeupdate", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("play", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("play"), EventOptions{
			Listen: []string{"playing"},
			Props:  []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "play")
		ref.Bind("play", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("pause", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pause"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pause")
		ref.Bind("pause", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("ended", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("ended"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "ended")
		ref.Bind("ended", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("volumechange", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("volumechange"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "volumechange")
		ref.Bind("volumechange", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("seeking", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("seeking"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "seeking")
		ref.Bind("seeking", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("seeked", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("seeked"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "seeked")
		ref.Bind("seeked", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.VideoState()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("ratechange", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("ratechange"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "ratechange")
		ref.Bind("ratechange", binding)
	}
}

// OnHTMLVideoElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementFocus(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLVideoElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementBlur(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLVideoElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementClick(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLVideoElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementDoubleClick(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLVideoElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementContextMenu(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLVideoElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementPointerDown(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLVideoElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementPointerUp(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLVideoElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementPointerMove(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLVideoElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementPointerEnter(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLVideoElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementPointerLeave(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLVideoElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementPointerOver(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLVideoElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementPointerOut(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLVideoElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementPointerCancel(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLVideoElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementWheel(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLVideoElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementKeyDown(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLVideoElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementKeyUp(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLVideoElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLVideoElement]) OnHTMLVideoElementKeyPress(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

// OnTimeUpdate registers a handler for the "timeupdate" event.
func (ref *ElementRef[HTMLVideoElement]) OnTimeUpdate(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("timeupdate", handler)
}

// OnPlay registers a handler for the "play" event.
func (ref *ElementRef[HTMLVideoElement]) OnPlay(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("play", handler)
}

// OnPause registers a handler for the "pause" event.
func (ref *ElementRef[HTMLVideoElement]) OnPause(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pause", handler)
}

// OnEnded registers a handler for the "ended" event.
func (ref *ElementRef[HTMLVideoElement]) OnEnded(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("ended", handler)
}

// OnVolumeChange registers a handler for the "volumechange" event.
func (ref *ElementRef[HTMLVideoElement]) OnVolumeChange(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("volumechange", handler)
}

// OnSeeking registers a handler for the "seeking" event.
func (ref *ElementRef[HTMLVideoElement]) OnSeeking(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("seeking", handler)
}

// OnSeeked registers a handler for the "seeked" event.
func (ref *ElementRef[HTMLVideoElement]) OnSeeked(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("seeked", handler)
}

// OnRateChange registers a handler for the "ratechange" event.
func (ref *ElementRef[HTMLVideoElement]) OnRateChange(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("ratechange", handler)
}

type HTMLWbrElementState struct {
	HTMLElementState
	HTMLKeyboardState
}

// WbrState returns the cached snapshot for the <wbr> element ref.
func (ref *ElementRef[HTMLWbrElement]) WbrState() HTMLWbrElementState {
	if ref == nil {
		return HTMLWbrElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLWbrElementState); ok {
		return raw
	}
	return HTMLWbrElementState{}
}

func (ref *ElementRef[HTMLWbrElement]) dispatchHTMLWbrElementEvent(event string, snapshot HTMLWbrElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLWbrElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLWbrElementState(prev HTMLWbrElementState, payload map[string]any) HTMLWbrElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.PointerID = payloadInt(payload, "event.pointerId", prev.PointerID)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.MovementX = payloadFloat(payload, "event.movementX", prev.MovementX)
	next.MovementY = payloadFloat(payload, "event.movementY", prev.MovementY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.PageX = payloadFloat(payload, "event.pageX", prev.PageX)
	next.PageY = payloadFloat(payload, "event.pageY", prev.PageY)
	next.ScreenX = payloadFloat(payload, "event.screenX", prev.ScreenX)
	next.ScreenY = payloadFloat(payload, "event.screenY", prev.ScreenY)
	next.IsPrimary = payloadBool(payload, "event.isPrimary", prev.IsPrimary)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	next.Key = payloadString(payload, "event.key", prev.Key)
	next.Code = payloadString(payload, "event.code", prev.Code)
	next.Location = payloadInt(payload, "event.location", prev.Location)
	next.Repeat = payloadBool(payload, "event.repeat", prev.Repeat)
	next.IsComposing = payloadBool(payload, "event.isComposing", prev.IsComposing)
	return next
}

func applyHTMLWbrElementDefaults(ref *ElementRef[HTMLWbrElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("dblclick", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("dblclick"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "dblclick")
		ref.Bind("dblclick", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("contextmenu", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("contextmenu"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "contextmenu")
		ref.Bind("contextmenu", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("pointerenter", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerenter"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerenter")
		ref.Bind("pointerenter", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("pointerleave", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerleave"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerleave")
		ref.Bind("pointerleave", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("pointerover", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerover"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerover")
		ref.Bind("pointerover", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("pointerout", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerout"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerout")
		ref.Bind("pointerout", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("pointercancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointercancel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointercancel")
		ref.Bind("pointercancel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("keyup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keyup"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keyup")
		ref.Bind("keyup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.WbrState()
			next := buildHTMLWbrElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLWbrElementEvent("keypress", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keypress"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.pointerType", "event.pointerId", "event.button", "event.buttons", "event.clientX", "event.clientY", "event.movementX", "event.movementY", "event.offsetX", "event.offsetY", "event.pageX", "event.pageY", "event.screenX", "event.screenY", "event.isPrimary", "event.deltaX", "event.deltaY", "event.deltaZ", "event.key", "event.code", "event.location", "event.repeat", "event.isComposing"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keypress")
		ref.Bind("keypress", binding)
	}
}

// OnHTMLWbrElementFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementFocus(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnHTMLWbrElementBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementBlur(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

// OnHTMLWbrElementClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementClick(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnHTMLWbrElementDoubleClick registers a handler for the "dblclick" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementDoubleClick(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("dblclick", handler)
}

// OnHTMLWbrElementContextMenu registers a handler for the "contextmenu" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementContextMenu(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("contextmenu", handler)
}

// OnHTMLWbrElementPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementPointerDown(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnHTMLWbrElementPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementPointerUp(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnHTMLWbrElementPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementPointerMove(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnHTMLWbrElementPointerEnter registers a handler for the "pointerenter" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementPointerEnter(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerenter", handler)
}

// OnHTMLWbrElementPointerLeave registers a handler for the "pointerleave" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementPointerLeave(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerleave", handler)
}

// OnHTMLWbrElementPointerOver registers a handler for the "pointerover" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementPointerOver(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerover", handler)
}

// OnHTMLWbrElementPointerOut registers a handler for the "pointerout" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementPointerOut(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerout", handler)
}

// OnHTMLWbrElementPointerCancel registers a handler for the "pointercancel" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementPointerCancel(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointercancel", handler)
}

// OnHTMLWbrElementWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementWheel(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

// OnHTMLWbrElementKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementKeyDown(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

// OnHTMLWbrElementKeyUp registers a handler for the "keyup" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementKeyUp(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keyup", handler)
}

// OnHTMLWbrElementKeyPress registers a handler for the "keypress" event.
func (ref *ElementRef[HTMLWbrElement]) OnHTMLWbrElementKeyPress(handler func(HTMLWbrElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keypress", handler)
}

func init() {
	prev := applyRefDefaultsFunc
	applyRefDefaultsFunc = func(ref any) {
		prev(ref)
		switch typed := ref.(type) {
		case *ElementRef[HTMLAElement]:
			applyHTMLAElementDefaults(typed)
		case *ElementRef[HTMLAbbrElement]:
			applyHTMLAbbrElementDefaults(typed)
		case *ElementRef[HTMLAddressElement]:
			applyHTMLAddressElementDefaults(typed)
		case *ElementRef[HTMLAreaElement]:
			applyHTMLAreaElementDefaults(typed)
		case *ElementRef[HTMLArticleElement]:
			applyHTMLArticleElementDefaults(typed)
		case *ElementRef[HTMLAsideElement]:
			applyHTMLAsideElementDefaults(typed)
		case *ElementRef[HTMLAudioElement]:
			applyHTMLAudioElementDefaults(typed)
		case *ElementRef[HTMLBElement]:
			applyHTMLBElementDefaults(typed)
		case *ElementRef[HTMLBaseElement]:
			applyHTMLBaseElementDefaults(typed)
		case *ElementRef[HTMLBdiElement]:
			applyHTMLBdiElementDefaults(typed)
		case *ElementRef[HTMLBdoElement]:
			applyHTMLBdoElementDefaults(typed)
		case *ElementRef[HTMLBlockquoteElement]:
			applyHTMLBlockquoteElementDefaults(typed)
		case *ElementRef[HTMLBodyElement]:
			applyHTMLBodyElementDefaults(typed)
		case *ElementRef[HTMLBrElement]:
			applyHTMLBrElementDefaults(typed)
		case *ElementRef[HTMLButtonElement]:
			applyHTMLButtonElementDefaults(typed)
		case *ElementRef[HTMLCanvasElement]:
			applyHTMLCanvasElementDefaults(typed)
		case *ElementRef[HTMLCaptionElement]:
			applyHTMLCaptionElementDefaults(typed)
		case *ElementRef[SVGCircleElement]:
			applySVGCircleElementDefaults(typed)
		case *ElementRef[HTMLCiteElement]:
			applyHTMLCiteElementDefaults(typed)
		case *ElementRef[SVGClipPathElement]:
			applySVGClipPathElementDefaults(typed)
		case *ElementRef[HTMLCodeElement]:
			applyHTMLCodeElementDefaults(typed)
		case *ElementRef[HTMLColElement]:
			applyHTMLColElementDefaults(typed)
		case *ElementRef[HTMLColgroupElement]:
			applyHTMLColgroupElementDefaults(typed)
		case *ElementRef[HTMLDataElement]:
			applyHTMLDataElementDefaults(typed)
		case *ElementRef[HTMLDatalistElement]:
			applyHTMLDatalistElementDefaults(typed)
		case *ElementRef[HTMLDdElement]:
			applyHTMLDdElementDefaults(typed)
		case *ElementRef[SVGDefsElement]:
			applySVGDefsElementDefaults(typed)
		case *ElementRef[HTMLDelElement]:
			applyHTMLDelElementDefaults(typed)
		case *ElementRef[HTMLDetailsElement]:
			applyHTMLDetailsElementDefaults(typed)
		case *ElementRef[HTMLDfnElement]:
			applyHTMLDfnElementDefaults(typed)
		case *ElementRef[HTMLDialogElement]:
			applyHTMLDialogElementDefaults(typed)
		case *ElementRef[HTMLDivElement]:
			applyHTMLDivElementDefaults(typed)
		case *ElementRef[HTMLDlElement]:
			applyHTMLDlElementDefaults(typed)
		case *ElementRef[HTMLDtElement]:
			applyHTMLDtElementDefaults(typed)
		case *ElementRef[SVGEllipseElement]:
			applySVGEllipseElementDefaults(typed)
		case *ElementRef[HTMLEmElement]:
			applyHTMLEmElementDefaults(typed)
		case *ElementRef[HTMLEmbedElement]:
			applyHTMLEmbedElementDefaults(typed)
		case *ElementRef[HTMLFieldsetElement]:
			applyHTMLFieldsetElementDefaults(typed)
		case *ElementRef[HTMLFigcaptionElement]:
			applyHTMLFigcaptionElementDefaults(typed)
		case *ElementRef[HTMLFigureElement]:
			applyHTMLFigureElementDefaults(typed)
		case *ElementRef[HTMLFooterElement]:
			applyHTMLFooterElementDefaults(typed)
		case *ElementRef[SVGForeignObjectElement]:
			applySVGForeignObjectElementDefaults(typed)
		case *ElementRef[HTMLFormElement]:
			applyHTMLFormElementDefaults(typed)
		case *ElementRef[SVGGElement]:
			applySVGGElementDefaults(typed)
		case *ElementRef[HTMLH1Element]:
			applyHTMLH1ElementDefaults(typed)
		case *ElementRef[HTMLH2Element]:
			applyHTMLH2ElementDefaults(typed)
		case *ElementRef[HTMLH3Element]:
			applyHTMLH3ElementDefaults(typed)
		case *ElementRef[HTMLH4Element]:
			applyHTMLH4ElementDefaults(typed)
		case *ElementRef[HTMLH5Element]:
			applyHTMLH5ElementDefaults(typed)
		case *ElementRef[HTMLH6Element]:
			applyHTMLH6ElementDefaults(typed)
		case *ElementRef[HTMLHeadElement]:
			applyHTMLHeadElementDefaults(typed)
		case *ElementRef[HTMLHeaderElement]:
			applyHTMLHeaderElementDefaults(typed)
		case *ElementRef[HTMLHgroupElement]:
			applyHTMLHgroupElementDefaults(typed)
		case *ElementRef[HTMLHrElement]:
			applyHTMLHrElementDefaults(typed)
		case *ElementRef[HTMLHtmlElement]:
			applyHTMLHtmlElementDefaults(typed)
		case *ElementRef[HTMLIElement]:
			applyHTMLIElementDefaults(typed)
		case *ElementRef[HTMLIframeElement]:
			applyHTMLIframeElementDefaults(typed)
		case *ElementRef[SVGImageElement]:
			applySVGImageElementDefaults(typed)
		case *ElementRef[HTMLImgElement]:
			applyHTMLImgElementDefaults(typed)
		case *ElementRef[HTMLInputElement]:
			applyHTMLInputElementDefaults(typed)
		case *ElementRef[HTMLInsElement]:
			applyHTMLInsElementDefaults(typed)
		case *ElementRef[HTMLKbdElement]:
			applyHTMLKbdElementDefaults(typed)
		case *ElementRef[HTMLLabelElement]:
			applyHTMLLabelElementDefaults(typed)
		case *ElementRef[HTMLLegendElement]:
			applyHTMLLegendElementDefaults(typed)
		case *ElementRef[HTMLLiElement]:
			applyHTMLLiElementDefaults(typed)
		case *ElementRef[SVGLineElement]:
			applySVGLineElementDefaults(typed)
		case *ElementRef[SVGLinearGradientElement]:
			applySVGLinearGradientElementDefaults(typed)
		case *ElementRef[HTMLLinkElement]:
			applyHTMLLinkElementDefaults(typed)
		case *ElementRef[HTMLMainElement]:
			applyHTMLMainElementDefaults(typed)
		case *ElementRef[HTMLMapElement]:
			applyHTMLMapElementDefaults(typed)
		case *ElementRef[HTMLMarkElement]:
			applyHTMLMarkElementDefaults(typed)
		case *ElementRef[SVGMarkerElement]:
			applySVGMarkerElementDefaults(typed)
		case *ElementRef[SVGMaskElement]:
			applySVGMaskElementDefaults(typed)
		case *ElementRef[HTMLMenuElement]:
			applyHTMLMenuElementDefaults(typed)
		case *ElementRef[HTMLMenuItemElement]:
			applyHTMLMenuItemElementDefaults(typed)
		case *ElementRef[HTMLMetaElement]:
			applyHTMLMetaElementDefaults(typed)
		case *ElementRef[HTMLMeterElement]:
			applyHTMLMeterElementDefaults(typed)
		case *ElementRef[HTMLNavElement]:
			applyHTMLNavElementDefaults(typed)
		case *ElementRef[HTMLNoscriptElement]:
			applyHTMLNoscriptElementDefaults(typed)
		case *ElementRef[HTMLObjectElement]:
			applyHTMLObjectElementDefaults(typed)
		case *ElementRef[HTMLOlElement]:
			applyHTMLOlElementDefaults(typed)
		case *ElementRef[HTMLOptgroupElement]:
			applyHTMLOptgroupElementDefaults(typed)
		case *ElementRef[HTMLOptionElement]:
			applyHTMLOptionElementDefaults(typed)
		case *ElementRef[HTMLOutputElement]:
			applyHTMLOutputElementDefaults(typed)
		case *ElementRef[HTMLPElement]:
			applyHTMLPElementDefaults(typed)
		case *ElementRef[HTMLParamElement]:
			applyHTMLParamElementDefaults(typed)
		case *ElementRef[SVGPathElement]:
			applySVGPathElementDefaults(typed)
		case *ElementRef[SVGPatternElement]:
			applySVGPatternElementDefaults(typed)
		case *ElementRef[HTMLPictureElement]:
			applyHTMLPictureElementDefaults(typed)
		case *ElementRef[SVGPolygonElement]:
			applySVGPolygonElementDefaults(typed)
		case *ElementRef[SVGPolylineElement]:
			applySVGPolylineElementDefaults(typed)
		case *ElementRef[HTMLPortalElement]:
			applyHTMLPortalElementDefaults(typed)
		case *ElementRef[HTMLPreElement]:
			applyHTMLPreElementDefaults(typed)
		case *ElementRef[HTMLProgressElement]:
			applyHTMLProgressElementDefaults(typed)
		case *ElementRef[HTMLQElement]:
			applyHTMLQElementDefaults(typed)
		case *ElementRef[SVGRadialGradientElement]:
			applySVGRadialGradientElementDefaults(typed)
		case *ElementRef[HTMLRbElement]:
			applyHTMLRbElementDefaults(typed)
		case *ElementRef[SVGRectElement]:
			applySVGRectElementDefaults(typed)
		case *ElementRef[HTMLRpElement]:
			applyHTMLRpElementDefaults(typed)
		case *ElementRef[HTMLRtElement]:
			applyHTMLRtElementDefaults(typed)
		case *ElementRef[HTMLRtcElement]:
			applyHTMLRtcElementDefaults(typed)
		case *ElementRef[HTMLRubyElement]:
			applyHTMLRubyElementDefaults(typed)
		case *ElementRef[HTMLSElement]:
			applyHTMLSElementDefaults(typed)
		case *ElementRef[HTMLSampElement]:
			applyHTMLSampElementDefaults(typed)
		case *ElementRef[HTMLScriptElement]:
			applyHTMLScriptElementDefaults(typed)
		case *ElementRef[HTMLSectionElement]:
			applyHTMLSectionElementDefaults(typed)
		case *ElementRef[HTMLSelectElement]:
			applyHTMLSelectElementDefaults(typed)
		case *ElementRef[HTMLSlotElement]:
			applyHTMLSlotElementDefaults(typed)
		case *ElementRef[HTMLSmallElement]:
			applyHTMLSmallElementDefaults(typed)
		case *ElementRef[HTMLSourceElement]:
			applyHTMLSourceElementDefaults(typed)
		case *ElementRef[HTMLSpanElement]:
			applyHTMLSpanElementDefaults(typed)
		case *ElementRef[SVGStopElement]:
			applySVGStopElementDefaults(typed)
		case *ElementRef[HTMLStrongElement]:
			applyHTMLStrongElementDefaults(typed)
		case *ElementRef[HTMLStyleElement]:
			applyHTMLStyleElementDefaults(typed)
		case *ElementRef[HTMLSubElement]:
			applyHTMLSubElementDefaults(typed)
		case *ElementRef[HTMLSummaryElement]:
			applyHTMLSummaryElementDefaults(typed)
		case *ElementRef[HTMLSupElement]:
			applyHTMLSupElementDefaults(typed)
		case *ElementRef[SVGSvgElement]:
			applySVGSvgElementDefaults(typed)
		case *ElementRef[SVGSvgTextElement]:
			applySVGSvgTextElementDefaults(typed)
		case *ElementRef[SVGTSpanElement]:
			applySVGTSpanElementDefaults(typed)
		case *ElementRef[HTMLTableElement]:
			applyHTMLTableElementDefaults(typed)
		case *ElementRef[HTMLTbodyElement]:
			applyHTMLTbodyElementDefaults(typed)
		case *ElementRef[HTMLTdElement]:
			applyHTMLTdElementDefaults(typed)
		case *ElementRef[HTMLTemplateElement]:
			applyHTMLTemplateElementDefaults(typed)
		case *ElementRef[HTMLTextareaElement]:
			applyHTMLTextareaElementDefaults(typed)
		case *ElementRef[HTMLTfootElement]:
			applyHTMLTfootElementDefaults(typed)
		case *ElementRef[HTMLThElement]:
			applyHTMLThElementDefaults(typed)
		case *ElementRef[HTMLTheadElement]:
			applyHTMLTheadElementDefaults(typed)
		case *ElementRef[HTMLTimeElement]:
			applyHTMLTimeElementDefaults(typed)
		case *ElementRef[HTMLTitleElement]:
			applyHTMLTitleElementDefaults(typed)
		case *ElementRef[HTMLTrElement]:
			applyHTMLTrElementDefaults(typed)
		case *ElementRef[HTMLTrackElement]:
			applyHTMLTrackElementDefaults(typed)
		case *ElementRef[HTMLUElement]:
			applyHTMLUElementDefaults(typed)
		case *ElementRef[HTMLUlElement]:
			applyHTMLUlElementDefaults(typed)
		case *ElementRef[SVGUseElement]:
			applySVGUseElementDefaults(typed)
		case *ElementRef[HTMLVarElement]:
			applyHTMLVarElementDefaults(typed)
		case *ElementRef[HTMLVideoElement]:
			applyHTMLVideoElementDefaults(typed)
		case *ElementRef[HTMLWbrElement]:
			applyHTMLWbrElementDefaults(typed)
		}
	}
}
