// Code generated by tags_gen.go; DO NOT EDIT.
package html

type HTMLAudioElementState struct {
	CurrentTime  float64
	Duration     float64
	Paused       bool
	Muted        bool
	Volume       float64
	Seeking      bool
	Ended        bool
	PlaybackRate float64
	ReadyState   int
}

// AudioState returns the cached snapshot for the <audio> element ref.
func (ref *ElementRef[HTMLAudioElement]) AudioState() HTMLAudioElementState {
	if ref == nil {
		return HTMLAudioElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLAudioElementState); ok {
		return raw
	}
	return HTMLAudioElementState{}
}

func (ref *ElementRef[HTMLAudioElement]) dispatchHTMLAudioElementEvent(event string, snapshot HTMLAudioElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLAudioElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLAudioElementState(prev HTMLAudioElementState, payload map[string]any) HTMLAudioElementState {
	next := prev
	next.CurrentTime = payloadFloat(payload, "target.currentTime", prev.CurrentTime)
	next.Duration = payloadFloat(payload, "target.duration", prev.Duration)
	next.Paused = payloadBool(payload, "target.paused", prev.Paused)
	next.Muted = payloadBool(payload, "target.muted", prev.Muted)
	next.Volume = payloadFloat(payload, "target.volume", prev.Volume)
	next.Seeking = payloadBool(payload, "target.seeking", prev.Seeking)
	next.Ended = payloadBool(payload, "target.ended", prev.Ended)
	next.PlaybackRate = payloadFloat(payload, "target.playbackRate", prev.PlaybackRate)
	next.ReadyState = payloadInt(payload, "target.readyState", prev.ReadyState)
	return next
}

func applyHTMLAudioElementDefaults(ref *ElementRef[HTMLAudioElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("timeupdate", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("timeupdate"), EventOptions{
			Listen: []string{"durationchange", "play", "pause", "seeking", "seeked"},
			Props:  []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "timeupdate")
		ref.Bind("timeupdate", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("play", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("play"), EventOptions{
			Listen: []string{"playing"},
			Props:  []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "play")
		ref.Bind("play", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("pause", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pause"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pause")
		ref.Bind("pause", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("ended", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("ended"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "ended")
		ref.Bind("ended", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("volumechange", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("volumechange"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "volumechange")
		ref.Bind("volumechange", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("seeking", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("seeking"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "seeking")
		ref.Bind("seeking", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("seeked", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("seeked"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "seeked")
		ref.Bind("seeked", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.AudioState()
			next := buildHTMLAudioElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLAudioElementEvent("ratechange", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("ratechange"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "ratechange")
		ref.Bind("ratechange", binding)
	}
}

// OnAudioTimeUpdate registers a handler for the "timeupdate" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioTimeUpdate(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("timeupdate", handler)
}

// OnAudioPlay registers a handler for the "play" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioPlay(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("play", handler)
}

// OnAudioPause registers a handler for the "pause" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioPause(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pause", handler)
}

// OnAudioEnded registers a handler for the "ended" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioEnded(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("ended", handler)
}

// OnAudioVolumeChange registers a handler for the "volumechange" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioVolumeChange(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("volumechange", handler)
}

// OnAudioSeeking registers a handler for the "seeking" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioSeeking(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("seeking", handler)
}

// OnAudioSeeked registers a handler for the "seeked" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioSeeked(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("seeked", handler)
}

// OnAudioRateChange registers a handler for the "ratechange" event.
func (ref *ElementRef[HTMLAudioElement]) OnAudioRateChange(handler func(HTMLAudioElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("ratechange", handler)
}

type HTMLButtonElementState struct {
	Disabled   bool
	Type       string
	Value      string
	Name       string
	FormAction string
	FormMethod string
}

// ButtonState returns the cached snapshot for the <button> element ref.
func (ref *ElementRef[HTMLButtonElement]) ButtonState() HTMLButtonElementState {
	if ref == nil {
		return HTMLButtonElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLButtonElementState); ok {
		return raw
	}
	return HTMLButtonElementState{}
}

func (ref *ElementRef[HTMLButtonElement]) dispatchHTMLButtonElementEvent(event string, snapshot HTMLButtonElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLButtonElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLButtonElementState(prev HTMLButtonElementState, payload map[string]any) HTMLButtonElementState {
	next := prev
	next.Disabled = payloadBool(payload, "target.disabled", prev.Disabled)
	next.Type = payloadString(payload, "target.type", prev.Type)
	next.Value = payloadString(payload, "target.value", prev.Value)
	next.Name = payloadString(payload, "target.name", prev.Name)
	next.FormAction = payloadString(payload, "target.formAction", prev.FormAction)
	next.FormMethod = payloadString(payload, "target.formMethod", prev.FormMethod)
	return next
}

func applyHTMLButtonElementDefaults(ref *ElementRef[HTMLButtonElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ButtonState()
			next := buildHTMLButtonElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLButtonElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"target.disabled", "target.type", "target.value", "target.name", "target.formAction", "target.formMethod"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
}

// OnButtonClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLButtonElement]) OnButtonClick(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnButtonFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLButtonElement]) OnButtonFocus(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnButtonBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLButtonElement]) OnButtonBlur(handler func(HTMLButtonElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

type HTMLCanvasElementState struct {
	PointerType        string
	Buttons            int
	ClientX            float64
	ClientY            float64
	OffsetX            float64
	OffsetY            float64
	Pressure           float64
	TangentialPressure float64
	TiltX              float64
	TiltY              float64
	WheelDeltaX        float64
	WheelDeltaY        float64
	WheelDeltaZ        float64
}

// CanvasState returns the cached snapshot for the <canvas> element ref.
func (ref *ElementRef[HTMLCanvasElement]) CanvasState() HTMLCanvasElementState {
	if ref == nil {
		return HTMLCanvasElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLCanvasElementState); ok {
		return raw
	}
	return HTMLCanvasElementState{}
}

func (ref *ElementRef[HTMLCanvasElement]) dispatchHTMLCanvasElementEvent(event string, snapshot HTMLCanvasElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLCanvasElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLCanvasElementState(prev HTMLCanvasElementState, payload map[string]any) HTMLCanvasElementState {
	next := prev
	next.PointerType = payloadString(payload, "event.pointerType", prev.PointerType)
	next.Buttons = payloadInt(payload, "event.buttons", prev.Buttons)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.OffsetX = payloadFloat(payload, "event.offsetX", prev.OffsetX)
	next.OffsetY = payloadFloat(payload, "event.offsetY", prev.OffsetY)
	next.Pressure = payloadFloat(payload, "event.pressure", prev.Pressure)
	next.TangentialPressure = payloadFloat(payload, "event.tangentialPressure", prev.TangentialPressure)
	next.TiltX = payloadFloat(payload, "event.tiltX", prev.TiltX)
	next.TiltY = payloadFloat(payload, "event.tiltY", prev.TiltY)
	next.WheelDeltaX = payloadFloat(payload, "event.deltaX", prev.WheelDeltaX)
	next.WheelDeltaY = payloadFloat(payload, "event.deltaY", prev.WheelDeltaY)
	next.WheelDeltaZ = payloadFloat(payload, "event.deltaZ", prev.WheelDeltaZ)
	return next
}

func applyHTMLCanvasElementDefaults(ref *ElementRef[HTMLCanvasElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("pointermove", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointermove"), EventOptions{
			Props: []string{"event.pointerType", "event.buttons", "event.clientX", "event.clientY", "event.offsetX", "event.offsetY", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY", "event.deltaX", "event.deltaY", "event.deltaZ"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointermove")
		ref.Bind("pointermove", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("pointerdown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerdown"), EventOptions{
			Props: []string{"event.pointerType", "event.buttons", "event.clientX", "event.clientY", "event.offsetX", "event.offsetY", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY", "event.deltaX", "event.deltaY", "event.deltaZ"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerdown")
		ref.Bind("pointerdown", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("pointerup", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pointerup"), EventOptions{
			Props: []string{"event.pointerType", "event.buttons", "event.clientX", "event.clientY", "event.offsetX", "event.offsetY", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY", "event.deltaX", "event.deltaY", "event.deltaZ"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pointerup")
		ref.Bind("pointerup", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.CanvasState()
			next := buildHTMLCanvasElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLCanvasElementEvent("wheel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("wheel"), EventOptions{
			Props: []string{"event.pointerType", "event.buttons", "event.clientX", "event.clientY", "event.offsetX", "event.offsetY", "event.pressure", "event.tangentialPressure", "event.tiltX", "event.tiltY", "event.deltaX", "event.deltaY", "event.deltaZ"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "wheel")
		ref.Bind("wheel", binding)
	}
}

// OnCanvasPointerMove registers a handler for the "pointermove" event.
func (ref *ElementRef[HTMLCanvasElement]) OnCanvasPointerMove(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointermove", handler)
}

// OnCanvasPointerDown registers a handler for the "pointerdown" event.
func (ref *ElementRef[HTMLCanvasElement]) OnCanvasPointerDown(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerdown", handler)
}

// OnCanvasPointerUp registers a handler for the "pointerup" event.
func (ref *ElementRef[HTMLCanvasElement]) OnCanvasPointerUp(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pointerup", handler)
}

// OnCanvasWheel registers a handler for the "wheel" event.
func (ref *ElementRef[HTMLCanvasElement]) OnCanvasWheel(handler func(HTMLCanvasElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("wheel", handler)
}

type HTMLDetailsElementState struct {
	Open bool
}

// DetailsState returns the cached snapshot for the <details> element ref.
func (ref *ElementRef[HTMLDetailsElement]) DetailsState() HTMLDetailsElementState {
	if ref == nil {
		return HTMLDetailsElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDetailsElementState); ok {
		return raw
	}
	return HTMLDetailsElementState{}
}

func (ref *ElementRef[HTMLDetailsElement]) dispatchHTMLDetailsElementEvent(event string, snapshot HTMLDetailsElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDetailsElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDetailsElementState(prev HTMLDetailsElementState, payload map[string]any) HTMLDetailsElementState {
	next := prev
	next.Open = payloadBool(payload, "target.open", prev.Open)
	return next
}

func applyHTMLDetailsElementDefaults(ref *ElementRef[HTMLDetailsElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DetailsState()
			next := buildHTMLDetailsElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDetailsElementEvent("toggle", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("toggle"), EventOptions{
			Props: []string{"target.open"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "toggle")
		ref.Bind("toggle", binding)
	}
}

// OnDetailsToggle registers a handler for the "toggle" event.
func (ref *ElementRef[HTMLDetailsElement]) OnDetailsToggle(handler func(HTMLDetailsElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("toggle", handler)
}

type HTMLDialogElementState struct {
	Open        bool
	ReturnValue string
}

// DialogState returns the cached snapshot for the <dialog> element ref.
func (ref *ElementRef[HTMLDialogElement]) DialogState() HTMLDialogElementState {
	if ref == nil {
		return HTMLDialogElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDialogElementState); ok {
		return raw
	}
	return HTMLDialogElementState{}
}

func (ref *ElementRef[HTMLDialogElement]) dispatchHTMLDialogElementEvent(event string, snapshot HTMLDialogElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDialogElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDialogElementState(prev HTMLDialogElementState, payload map[string]any) HTMLDialogElementState {
	next := prev
	next.Open = payloadBool(payload, "target.open", prev.Open)
	next.ReturnValue = payloadString(payload, "target.returnValue", prev.ReturnValue)
	return next
}

func applyHTMLDialogElementDefaults(ref *ElementRef[HTMLDialogElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("close", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("close"), EventOptions{
			Props: []string{"target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "close")
		ref.Bind("close", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DialogState()
			next := buildHTMLDialogElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDialogElementEvent("cancel", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("cancel"), EventOptions{
			Props: []string{"target.open", "target.returnValue"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "cancel")
		ref.Bind("cancel", binding)
	}
}

// OnDialogClose registers a handler for the "close" event.
func (ref *ElementRef[HTMLDialogElement]) OnDialogClose(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("close", handler)
}

// OnDialogCancel registers a handler for the "cancel" event.
func (ref *ElementRef[HTMLDialogElement]) OnDialogCancel(handler func(HTMLDialogElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("cancel", handler)
}

type HTMLDivElementState struct {
	AltKey   bool
	CtrlKey  bool
	ShiftKey bool
	MetaKey  bool
	Button   int
	ClientX  float64
	ClientY  float64
	TargetID string
}

// DivState returns the cached snapshot for the <div> element ref.
func (ref *ElementRef[HTMLDivElement]) DivState() HTMLDivElementState {
	if ref == nil {
		return HTMLDivElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLDivElementState); ok {
		return raw
	}
	return HTMLDivElementState{}
}

func (ref *ElementRef[HTMLDivElement]) dispatchHTMLDivElementEvent(event string, snapshot HTMLDivElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLDivElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLDivElementState(prev HTMLDivElementState, payload map[string]any) HTMLDivElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.ClientX = payloadFloat(payload, "event.clientX", prev.ClientX)
	next.ClientY = payloadFloat(payload, "event.clientY", prev.ClientY)
	next.TargetID = payloadString(payload, "target.id", prev.TargetID)
	return next
}

func applyHTMLDivElementDefaults(ref *ElementRef[HTMLDivElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.detail", "event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.button", "event.clientX", "event.clientY", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.DivState()
			next := buildHTMLDivElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLDivElementEvent("drag", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("drag"), EventOptions{
			Listen: []string{"dragstart", "dragend"},
			Props:  []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.button", "event.clientX", "event.clientY", "target.id"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "drag")
		ref.Bind("drag", binding)
	}
}

// OnDivClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLDivElement]) OnDivClick(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnDivDrag registers a handler for the "drag" event.
func (ref *ElementRef[HTMLDivElement]) OnDivDrag(handler func(HTMLDivElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("drag", handler)
}

type HTMLFormElementState struct {
	Action     string
	Method     string
	NoValidate bool
	Target     string
	Encoding   string
	Name       string
}

// FormState returns the cached snapshot for the <form> element ref.
func (ref *ElementRef[HTMLFormElement]) FormState() HTMLFormElementState {
	if ref == nil {
		return HTMLFormElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLFormElementState); ok {
		return raw
	}
	return HTMLFormElementState{}
}

func (ref *ElementRef[HTMLFormElement]) dispatchHTMLFormElementEvent(event string, snapshot HTMLFormElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLFormElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLFormElementState(prev HTMLFormElementState, payload map[string]any) HTMLFormElementState {
	next := prev
	next.Action = payloadString(payload, "target.action", prev.Action)
	next.Method = payloadString(payload, "target.method", prev.Method)
	next.NoValidate = payloadBool(payload, "target.noValidate", prev.NoValidate)
	next.Target = payloadString(payload, "target.target", prev.Target)
	next.Encoding = payloadString(payload, "target.enctype", prev.Encoding)
	next.Name = payloadString(payload, "target.name", prev.Name)
	return next
}

func applyHTMLFormElementDefaults(ref *ElementRef[HTMLFormElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("submit", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("submit"), EventOptions{
			Listen: []string{"formdata"},
			Props:  []string{"target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "submit")
		ref.Bind("submit", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("reset", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("reset"), EventOptions{
			Props: []string{"target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "reset")
		ref.Bind("reset", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.FormState()
			next := buildHTMLFormElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLFormElementEvent("invalid", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("invalid"), EventOptions{
			Props: []string{"target.action", "target.method", "target.noValidate", "target.target", "target.enctype", "target.name"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "invalid")
		ref.Bind("invalid", binding)
	}
}

// OnFormSubmit registers a handler for the "submit" event.
func (ref *ElementRef[HTMLFormElement]) OnFormSubmit(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("submit", handler)
}

// OnFormReset registers a handler for the "reset" event.
func (ref *ElementRef[HTMLFormElement]) OnFormReset(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("reset", handler)
}

// OnFormInvalid registers a handler for the "invalid" event.
func (ref *ElementRef[HTMLFormElement]) OnFormInvalid(handler func(HTMLFormElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("invalid", handler)
}

type HTMLInputElementState struct {
	Value          string
	Checked        bool
	Type           string
	Name           string
	Disabled       bool
	Required       bool
	SelectionStart int
	SelectionEnd   int
}

// InputState returns the cached snapshot for the <input> element ref.
func (ref *ElementRef[HTMLInputElement]) InputState() HTMLInputElementState {
	if ref == nil {
		return HTMLInputElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLInputElementState); ok {
		return raw
	}
	return HTMLInputElementState{}
}

func (ref *ElementRef[HTMLInputElement]) dispatchHTMLInputElementEvent(event string, snapshot HTMLInputElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLInputElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLInputElementState(prev HTMLInputElementState, payload map[string]any) HTMLInputElementState {
	next := prev
	next.Value = payloadString(payload, "target.value", prev.Value)
	next.Checked = payloadBool(payload, "target.checked", prev.Checked)
	next.Type = payloadString(payload, "target.type", prev.Type)
	next.Name = payloadString(payload, "target.name", prev.Name)
	next.Disabled = payloadBool(payload, "target.disabled", prev.Disabled)
	next.Required = payloadBool(payload, "target.required", prev.Required)
	next.SelectionStart = payloadInt(payload, "target.selectionStart", prev.SelectionStart)
	next.SelectionEnd = payloadInt(payload, "target.selectionEnd", prev.SelectionEnd)
	return next
}

func applyHTMLInputElementDefaults(ref *ElementRef[HTMLInputElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("input", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("input"), EventOptions{
			Props: []string{"event.inputType", "event.isComposing", "target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "input")
		ref.Bind("input", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("change", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("change"), EventOptions{
			Props: []string{"target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "change")
		ref.Bind("change", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("focus", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("focus"), EventOptions{
			Props: []string{"target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "focus")
		ref.Bind("focus", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.InputState()
			next := buildHTMLInputElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLInputElementEvent("blur", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("blur"), EventOptions{
			Props: []string{"target.value", "target.checked", "target.type", "target.name", "target.disabled", "target.required", "target.selectionStart", "target.selectionEnd"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "blur")
		ref.Bind("blur", binding)
	}
}

// OnInput registers a handler for the "input" event.
func (ref *ElementRef[HTMLInputElement]) OnInput(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("input", handler)
}

// OnChange registers a handler for the "change" event.
func (ref *ElementRef[HTMLInputElement]) OnChange(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("change", handler)
}

// OnFocus registers a handler for the "focus" event.
func (ref *ElementRef[HTMLInputElement]) OnFocus(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("focus", handler)
}

// OnBlur registers a handler for the "blur" event.
func (ref *ElementRef[HTMLInputElement]) OnBlur(handler func(HTMLInputElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("blur", handler)
}

type HTMLMeterElementState struct {
	Value   float64
	Min     float64
	Max     float64
	Low     float64
	High    float64
	Optimum float64
}

// MeterState returns the cached snapshot for the <meter> element ref.
func (ref *ElementRef[HTMLMeterElement]) MeterState() HTMLMeterElementState {
	if ref == nil {
		return HTMLMeterElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLMeterElementState); ok {
		return raw
	}
	return HTMLMeterElementState{}
}

func (ref *ElementRef[HTMLMeterElement]) dispatchHTMLMeterElementEvent(event string, snapshot HTMLMeterElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLMeterElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLMeterElementState(prev HTMLMeterElementState, payload map[string]any) HTMLMeterElementState {
	next := prev
	next.Value = payloadFloat(payload, "target.value", prev.Value)
	next.Min = payloadFloat(payload, "target.min", prev.Min)
	next.Max = payloadFloat(payload, "target.max", prev.Max)
	next.Low = payloadFloat(payload, "target.low", prev.Low)
	next.High = payloadFloat(payload, "target.high", prev.High)
	next.Optimum = payloadFloat(payload, "target.optimum", prev.Optimum)
	return next
}

func applyHTMLMeterElementDefaults(ref *ElementRef[HTMLMeterElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("change", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("change"), EventOptions{
			Props: []string{"target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "change")
		ref.Bind("change", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.MeterState()
			next := buildHTMLMeterElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLMeterElementEvent("input", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("input"), EventOptions{
			Props: []string{"target.value", "target.min", "target.max", "target.low", "target.high", "target.optimum"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "input")
		ref.Bind("input", binding)
	}
}

// OnMeterChange registers a handler for the "change" event.
func (ref *ElementRef[HTMLMeterElement]) OnMeterChange(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("change", handler)
}

// OnMeterInput registers a handler for the "input" event.
func (ref *ElementRef[HTMLMeterElement]) OnMeterInput(handler func(HTMLMeterElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("input", handler)
}

type HTMLProgressElementState struct {
	Value    float64
	Max      float64
	Position float64
}

// ProgressState returns the cached snapshot for the <progress> element ref.
func (ref *ElementRef[HTMLProgressElement]) ProgressState() HTMLProgressElementState {
	if ref == nil {
		return HTMLProgressElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLProgressElementState); ok {
		return raw
	}
	return HTMLProgressElementState{}
}

func (ref *ElementRef[HTMLProgressElement]) dispatchHTMLProgressElementEvent(event string, snapshot HTMLProgressElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLProgressElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLProgressElementState(prev HTMLProgressElementState, payload map[string]any) HTMLProgressElementState {
	next := prev
	next.Value = payloadFloat(payload, "target.value", prev.Value)
	next.Max = payloadFloat(payload, "target.max", prev.Max)
	next.Position = payloadFloat(payload, "target.position", prev.Position)
	return next
}

func applyHTMLProgressElementDefaults(ref *ElementRef[HTMLProgressElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.ProgressState()
			next := buildHTMLProgressElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLProgressElementEvent("change", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("change"), EventOptions{
			Props: []string{"target.value", "target.max", "target.position"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "change")
		ref.Bind("change", binding)
	}
}

// OnProgressChange registers a handler for the "change" event.
func (ref *ElementRef[HTMLProgressElement]) OnProgressChange(handler func(HTMLProgressElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("change", handler)
}

type HTMLSelectElementState struct {
	Value         string
	SelectedIndex int
	Length        int
	Multiple      bool
}

// SelectState returns the cached snapshot for the <select> element ref.
func (ref *ElementRef[HTMLSelectElement]) SelectState() HTMLSelectElementState {
	if ref == nil {
		return HTMLSelectElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSelectElementState); ok {
		return raw
	}
	return HTMLSelectElementState{}
}

func (ref *ElementRef[HTMLSelectElement]) dispatchHTMLSelectElementEvent(event string, snapshot HTMLSelectElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSelectElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSelectElementState(prev HTMLSelectElementState, payload map[string]any) HTMLSelectElementState {
	next := prev
	next.Value = payloadString(payload, "target.value", prev.Value)
	next.SelectedIndex = payloadInt(payload, "target.selectedIndex", prev.SelectedIndex)
	next.Length = payloadInt(payload, "target.length", prev.Length)
	next.Multiple = payloadBool(payload, "target.multiple", prev.Multiple)
	return next
}

func applyHTMLSelectElementDefaults(ref *ElementRef[HTMLSelectElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("change", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("change"), EventOptions{
			Props: []string{"target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "change")
		ref.Bind("change", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SelectState()
			next := buildHTMLSelectElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSelectElementEvent("input", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("input"), EventOptions{
			Props: []string{"target.value", "target.selectedIndex", "target.length", "target.multiple"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "input")
		ref.Bind("input", binding)
	}
}

// OnSelectChange registers a handler for the "change" event.
func (ref *ElementRef[HTMLSelectElement]) OnSelectChange(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("change", handler)
}

// OnSelectInput registers a handler for the "input" event.
func (ref *ElementRef[HTMLSelectElement]) OnSelectInput(handler func(HTMLSelectElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("input", handler)
}

type HTMLSummaryElementState struct {
	AltKey   bool
	CtrlKey  bool
	ShiftKey bool
	MetaKey  bool
	Button   int
	Detail   int
}

// SummaryState returns the cached snapshot for the <summary> element ref.
func (ref *ElementRef[HTMLSummaryElement]) SummaryState() HTMLSummaryElementState {
	if ref == nil {
		return HTMLSummaryElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLSummaryElementState); ok {
		return raw
	}
	return HTMLSummaryElementState{}
}

func (ref *ElementRef[HTMLSummaryElement]) dispatchHTMLSummaryElementEvent(event string, snapshot HTMLSummaryElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLSummaryElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLSummaryElementState(prev HTMLSummaryElementState, payload map[string]any) HTMLSummaryElementState {
	next := prev
	next.AltKey = payloadBool(payload, "event.altKey", prev.AltKey)
	next.CtrlKey = payloadBool(payload, "event.ctrlKey", prev.CtrlKey)
	next.ShiftKey = payloadBool(payload, "event.shiftKey", prev.ShiftKey)
	next.MetaKey = payloadBool(payload, "event.metaKey", prev.MetaKey)
	next.Button = payloadInt(payload, "event.button", prev.Button)
	next.Detail = payloadInt(payload, "event.detail", prev.Detail)
	return next
}

func applyHTMLSummaryElementDefaults(ref *ElementRef[HTMLSummaryElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("click", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("click"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.button", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "click")
		ref.Bind("click", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.SummaryState()
			next := buildHTMLSummaryElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLSummaryElementEvent("keydown", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("keydown"), EventOptions{
			Props: []string{"event.altKey", "event.ctrlKey", "event.shiftKey", "event.metaKey", "event.button", "event.detail"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "keydown")
		ref.Bind("keydown", binding)
	}
}

// OnSummaryClick registers a handler for the "click" event.
func (ref *ElementRef[HTMLSummaryElement]) OnSummaryClick(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("click", handler)
}

// OnSummaryKeyDown registers a handler for the "keydown" event.
func (ref *ElementRef[HTMLSummaryElement]) OnSummaryKeyDown(handler func(HTMLSummaryElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("keydown", handler)
}

type HTMLTextareaElementState struct {
	Value          string
	SelectionStart int
	SelectionEnd   int
	Rows           int
	Cols           int
	Disabled       bool
}

// TextareaState returns the cached snapshot for the <textarea> element ref.
func (ref *ElementRef[HTMLTextareaElement]) TextareaState() HTMLTextareaElementState {
	if ref == nil {
		return HTMLTextareaElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLTextareaElementState); ok {
		return raw
	}
	return HTMLTextareaElementState{}
}

func (ref *ElementRef[HTMLTextareaElement]) dispatchHTMLTextareaElementEvent(event string, snapshot HTMLTextareaElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLTextareaElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLTextareaElementState(prev HTMLTextareaElementState, payload map[string]any) HTMLTextareaElementState {
	next := prev
	next.Value = payloadString(payload, "target.value", prev.Value)
	next.SelectionStart = payloadInt(payload, "target.selectionStart", prev.SelectionStart)
	next.SelectionEnd = payloadInt(payload, "target.selectionEnd", prev.SelectionEnd)
	next.Rows = payloadInt(payload, "target.rows", prev.Rows)
	next.Cols = payloadInt(payload, "target.cols", prev.Cols)
	next.Disabled = payloadBool(payload, "target.disabled", prev.Disabled)
	return next
}

func applyHTMLTextareaElementDefaults(ref *ElementRef[HTMLTextareaElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("input", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("input"), EventOptions{
			Props: []string{"event.inputType", "event.isComposing", "target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "input")
		ref.Bind("input", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("change", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("change"), EventOptions{
			Props: []string{"target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "change")
		ref.Bind("change", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.TextareaState()
			next := buildHTMLTextareaElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLTextareaElementEvent("select", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("select"), EventOptions{
			Props: []string{"target.value", "target.selectionStart", "target.selectionEnd", "target.rows", "target.cols", "target.disabled"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "select")
		ref.Bind("select", binding)
	}
}

// OnTextareaInput registers a handler for the "input" event.
func (ref *ElementRef[HTMLTextareaElement]) OnTextareaInput(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("input", handler)
}

// OnTextareaChange registers a handler for the "change" event.
func (ref *ElementRef[HTMLTextareaElement]) OnTextareaChange(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("change", handler)
}

// OnTextareaSelect registers a handler for the "select" event.
func (ref *ElementRef[HTMLTextareaElement]) OnTextareaSelect(handler func(HTMLTextareaElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("select", handler)
}

type HTMLVideoElementState struct {
	CurrentTime  float64
	Duration     float64
	Paused       bool
	Muted        bool
	Volume       float64
	Seeking      bool
	Ended        bool
	PlaybackRate float64
	ReadyState   int
}

// State returns the cached snapshot for the <video> element ref.
func (ref *ElementRef[HTMLVideoElement]) State() HTMLVideoElementState {
	if ref == nil {
		return HTMLVideoElementState{}
	}
	if raw, ok := ref.CachedState().(HTMLVideoElementState); ok {
		return raw
	}
	return HTMLVideoElementState{}
}

func (ref *ElementRef[HTMLVideoElement]) dispatchHTMLVideoElementEvent(event string, snapshot HTMLVideoElementState, evt Event) Updates {
	var result Updates
	for _, raw := range ref.listenersFor(event) {
		cb, ok := raw.(func(HTMLVideoElementState, Event) Updates)
		if !ok {
			continue
		}
		if out := cb(snapshot, evt); out != nil {
			result = out
		}
	}
	return result
}

func buildHTMLVideoElementState(prev HTMLVideoElementState, payload map[string]any) HTMLVideoElementState {
	next := prev
	next.CurrentTime = payloadFloat(payload, "target.currentTime", prev.CurrentTime)
	next.Duration = payloadFloat(payload, "target.duration", prev.Duration)
	next.Paused = payloadBool(payload, "target.paused", prev.Paused)
	next.Muted = payloadBool(payload, "target.muted", prev.Muted)
	next.Volume = payloadFloat(payload, "target.volume", prev.Volume)
	next.Seeking = payloadBool(payload, "target.seeking", prev.Seeking)
	next.Ended = payloadBool(payload, "target.ended", prev.Ended)
	next.PlaybackRate = payloadFloat(payload, "target.playbackRate", prev.PlaybackRate)
	next.ReadyState = payloadInt(payload, "target.readyState", prev.ReadyState)
	return next
}

func applyHTMLVideoElementDefaults(ref *ElementRef[HTMLVideoElement]) {
	if ref == nil {
		return
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.State()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("timeupdate", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("timeupdate"), EventOptions{
			Listen: []string{"durationchange", "play", "pause", "seeking", "seeked"},
			Props:  []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "timeupdate")
		ref.Bind("timeupdate", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.State()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("play", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("play"), EventOptions{
			Listen: []string{"playing"},
			Props:  []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "play")
		ref.Bind("play", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.State()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("pause", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("pause"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "pause")
		ref.Bind("pause", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.State()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("ended", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("ended"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "ended")
		ref.Bind("ended", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.State()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("volumechange", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("volumechange"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "volumechange")
		ref.Bind("volumechange", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.State()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("seeking", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("seeking"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "seeking")
		ref.Bind("seeking", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.State()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("seeked", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("seeked"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "seeked")
		ref.Bind("seeked", binding)
	}
	{
		handler := func(evt Event) Updates {
			prev := ref.State()
			next := buildHTMLVideoElementState(prev, evt.Payload)
			ref.updateState(next)
			return ref.dispatchHTMLVideoElementEvent("ratechange", next, evt)
		}
		opts := mergeEventOptions(defaultEventOptions("ratechange"), EventOptions{
			Props: []string{"target.currentTime", "target.duration", "target.paused", "target.muted", "target.volume", "target.seeking", "target.ended", "target.playbackRate", "target.readyState"},
		})
		binding := (EventBinding{Handler: handler}).withOptions(opts, "ratechange")
		ref.Bind("ratechange", binding)
	}
}

// OnTimeUpdate registers a handler for the "timeupdate" event.
func (ref *ElementRef[HTMLVideoElement]) OnTimeUpdate(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("timeupdate", handler)
}

// OnPlay registers a handler for the "play" event.
func (ref *ElementRef[HTMLVideoElement]) OnPlay(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("play", handler)
}

// OnPause registers a handler for the "pause" event.
func (ref *ElementRef[HTMLVideoElement]) OnPause(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("pause", handler)
}

// OnEnded registers a handler for the "ended" event.
func (ref *ElementRef[HTMLVideoElement]) OnEnded(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("ended", handler)
}

// OnVolumeChange registers a handler for the "volumechange" event.
func (ref *ElementRef[HTMLVideoElement]) OnVolumeChange(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("volumechange", handler)
}

// OnSeeking registers a handler for the "seeking" event.
func (ref *ElementRef[HTMLVideoElement]) OnSeeking(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("seeking", handler)
}

// OnSeeked registers a handler for the "seeked" event.
func (ref *ElementRef[HTMLVideoElement]) OnSeeked(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("seeked", handler)
}

// OnRateChange registers a handler for the "ratechange" event.
func (ref *ElementRef[HTMLVideoElement]) OnRateChange(handler func(HTMLVideoElementState, Event) Updates) {
	if ref == nil || handler == nil {
		return
	}
	ref.addListener("ratechange", handler)
}

func init() {
	prev := applyRefDefaultsFunc
	applyRefDefaultsFunc = func(ref any) {
		prev(ref)
		switch typed := ref.(type) {
		case *ElementRef[HTMLAudioElement]:
			applyHTMLAudioElementDefaults(typed)
		case *ElementRef[HTMLButtonElement]:
			applyHTMLButtonElementDefaults(typed)
		case *ElementRef[HTMLCanvasElement]:
			applyHTMLCanvasElementDefaults(typed)
		case *ElementRef[HTMLDetailsElement]:
			applyHTMLDetailsElementDefaults(typed)
		case *ElementRef[HTMLDialogElement]:
			applyHTMLDialogElementDefaults(typed)
		case *ElementRef[HTMLDivElement]:
			applyHTMLDivElementDefaults(typed)
		case *ElementRef[HTMLFormElement]:
			applyHTMLFormElementDefaults(typed)
		case *ElementRef[HTMLInputElement]:
			applyHTMLInputElementDefaults(typed)
		case *ElementRef[HTMLMeterElement]:
			applyHTMLMeterElementDefaults(typed)
		case *ElementRef[HTMLProgressElement]:
			applyHTMLProgressElementDefaults(typed)
		case *ElementRef[HTMLSelectElement]:
			applyHTMLSelectElementDefaults(typed)
		case *ElementRef[HTMLSummaryElement]:
			applyHTMLSummaryElementDefaults(typed)
		case *ElementRef[HTMLTextareaElement]:
			applyHTMLTextareaElementDefaults(typed)
		case *ElementRef[HTMLVideoElement]:
			applyHTMLVideoElementDefaults(typed)
		}
	}
}
