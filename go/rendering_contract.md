# Rendering System Architecture: Complete Specification

## 1. Overview

This document defines the full architecture, components, lifecycle, and contracts of your rendering system. It reflects the finalized model we developed: a clear separation between **Work Trees**, **Component Instances**, and **View Trees**. This document is intentionally exhaustive and detailed by design—your “one‑stop shop” for fully understanding and implementing rendering logic.

---

# 2. Key Entities

The rendering system has **three distinct layers**:

1. **Work Layer** – Work Trees (ephemeral, descriptive)
2. **Runtime Layer** – Component Instances (persistent state/effects)
3. **View Layer** – View Trees (persistent structural output)

Each serves a different purpose.

---

# 3. Work Tree (Work Nodes)

## 3.1 Purpose

The **Work Tree** is the output of executing your Go component functions.  
It represents what the UI *should* look like **for this render only**.

Characteristics:

- Ephemeral (new tree for every render)
- Never diffed
- Never stored after render finishes
- Contains component calls (`WorkComponentNode`)

## 3.2 Kinds of Work Nodes

### 3.2.1 `WorkComponentNode`

Represents a request to **call a component function**:

- `Call`: the Go function pointer
- `Props`: props for the component
- `Children`: WorkNodes passed as logical children

It does **not** contain state, effects, or DOM.

### 3.2.2 `WorkElementNode`

Represents a primitive element (like `<div>`):

- `Tag`
- `Props`
- `Children` (`[]WorkNode`)

Generated by helpers like `h.Div()`.

### 3.2.3 `WorkTextNode`

Represents text content.

- `Value: string`

### 3.2.4 `WorkFragmentNode`

Represents multiple children with no wrapper.

- `Children: []WorkNode`

---

# 4. View Tree (View Nodes)

## 4.1 Purpose

The **View Tree** is the persistent, finalized structure of the UI.

Characteristics:

- Stored across renders
- Used for diffing
- Maps to DOM/HTML
- Contains NO component logic

## 4.2 Kinds of View Nodes

### 4.2.1 `ViewElementNode`

- `Tag`
- `Props`
- `Children`: ViewNodes
- `DomRef`: pointer to actual DOM element (client side)

### 4.2.2 `ViewTextNode`

- `Value`
- `DomRef`

### 4.2.3 `ViewFragmentNode`

Logical grouping of children.

---

# 5. Component Instances

## 5.1 Purpose

A **Component Instance** is the *runtime identity* of a mounted component.
It stores all long-lived state and effects.

Each instance is tied to one component function at one position in the tree.

## 5.2 Where they live

Component instances exist **only inside the Session**, not inside Work Trees or View Trees.

## 5.3 Fields of ComponentInstance

```
ComponentInstance {
    Call          // component function
    Props         // last props
    Children      // last input Work children
    HookCells[]   // useState, useRef, memo, etc.
    Effects[]     // effect descriptions & deps
    RenderedRoot  // ViewNode subtree from last render
    Key/Identity  // identity tracking
}
```

They persist across renders as long as the component keeps appearing in the tree.

---

# 6. Session

The **Session** is the global runtime context for one UI execution.  
It owns:

- All `ComponentInstance`s
- The root `ViewNode` (current UI)
- The mapping mechanism that ties Work nodes to their instances

The session is **not a tree**, but *contains* the instances which *reflect* the component hierarchy.

---

# 7. Rendering Process

Rendering has **two major phases**:

1. **Build Work Tree** (Go execution)
2. **Resolve Work Tree → View Tree** (renderer execution)

After View Tree is produced, the renderer diffs it against the previous View Tree and commits DOM updates.

---

# 8. Phase 1: Build Work Tree (Go Side)

When the root component is executed:

```
rootWork := RootComponent(ctx)
```

The Go code returns a **WorkNode** tree.

Notes:

- Work nodes may contain components (`WorkComponentNode`)
- Work nodes may contain primitives (`WorkElementNode`)
- This is a pure function of props + state (accessed via hooks)

No DOM or diffing happens here.

---

# 9. Phase 2: Resolve Work Tree → View Tree

The renderer processes the Work Tree recursively.

Pseudocode:

```
resolve(workNode) -> ViewNode
```

## 9.1 If WorkComponentNode

1. Locate or create ComponentInstance.
2. Set current instance (so useState/useEffect know where to act).
3. Call `Call(props, children)` → returns a child WorkNode.
4. Resolve that child WorkNode recursively.
5. Store result as `instance.RenderedRoot`.
6. Return the View subtree.

## 9.2 If WorkElementNode

1. Resolve all children WorkNodes into ViewNodes.
2. Create ViewElementNode.
3. Attach DOM element on client.
4. Return ViewElementNode.

## 9.3 If WorkTextNode

Return a ViewTextNode with DOM text.

## 9.4 If WorkFragmentNode

Resolve each child and return ViewFragmentNode.

---

# 10. Diffing & Commit Phase

After generating a new View Tree:

- Compare it to the Session’s previous View Tree.
- Diff node by node:
  - Replace when tag/type changes
  - Update props when changed
  - Update text when changed
  - Reconcile children (index-based or keyed)
- Patch actual DOM nodes (client-side)
- Store new View Tree as current

Only **View trees** are diffed.

---

# 11. ComponentInstance Lifecycle

## 11.1 Mount

When resolving a WorkComponentNode:

- If no instance exists at that position:
  - Create a new ComponentInstance
  - Initialize HookCells, Effects, Props, etc.

## 11.2 Reuse

On subsequent renders:

- Match WorkComponentNode with existing instance via position/key
- Reuse the same ComponentInstance
- Update Props & Children
- Keep HookCells & Effects intact
- Re-render only if needed

## 11.3 Unmount

If a WorkComponentNode disappears from the new Work Tree:

- The corresponding ComponentInstance must:
  - Run effect cleanups
  - Remove its View subtree from DOM
  - Be removed from the Session

---

# 12. Hooks

## 12.1 Where hook state lives

Hook state **does not** live:

- On WorkNodes
- On ViewNodes

Hook state lives **only on ComponentInstances** inside `HookCells`.

## 12.2 UseState

- `UseState` returns a value accessor and setter.
- Setter updates the HookCell and marks the instance “dirty”.
- Dirty instances trigger a re-render.

## 12.3 UseEffect

- Effects registered during render are stored in `Effects[]`.
- After committing the View Tree:
  - Compare deps to previous deps
  - Run new effects
  - Run cleanups when needed

Effects also live only on ComponentInstances.

---

# 13. Identity Rules

A ComponentInstance survives if:

- The same component type appears
- In the same structural position
- With the same key (if you use keys)

If not, a new instance is created.

---

# 14. Invariants (Critical Short Version)

You should re-read these every day:

1. **Work Tree = ephemeral. Never stored. Never diffed.**
2. **View Tree = persistent. Always diffed.**
3. **ComponentInstances = persistent memory for components.**
4. **Hooks & effects live on ComponentInstances, not nodes.**
5. **WorkComponentNode → ComponentInstance → returns WorkTree → becomes ViewTree.**
6. **Only ViewNodes are converted to DOM.**
7. **If a component disappears from the WorkTree, unmount its instance.**
8. **Go code builds the WorkTree. Renderer resolves it.**
9. **The WorkTree is the recipe; the ViewTree is the rendered dish.**

---

# 15. Mental Model Summary

- **Work Tree** = “What the developer says the UI should be this frame.”
- **ComponentInstances** = “Who remembers things between frames.”
- **View Tree** = “What is actually on the screen right now.”

Work Tree → (resolve + ComponentInstances) → View Tree → (diff) → DOM

---

# 16. Example: A → B → C

## Work Tree

```
A()
 └── WorkComponentNode(B)
         └── WorkComponentNode(C)
                 └── WorkElementNode("div")
                         └── WorkTextNode("hello")
```

## Component Instances (Session)

```
A_Instance
  B_Instance
    C_Instance
```

## View Tree

```
<div>
  "hello"
</div>
```

---

# 17. Final Notes

This architecture guarantees:

- Predictable updates  
- Clean diffing  
- Proper state persistence  
- Isolation between layers  
- Clear boundaries between description (Work) and output (View)

This is your full rendering contract.

Use this document as your reference for implementing the full renderer pipeline.

