# Clean Handler & Ref Hydration

This proposal removes every LiveUI-specific attribute (`data-on*`,
`data-router-*`, `data-live-ref`, …) from server-rendered HTML while keeping the
runtime’s ability to hydrate handlers, router metadata, and refs. The goal is
parity: “what developers author in Go is exactly what lands in the browser.”

## 1. Current Problems

1. **HTML pollution** – SSR injects `data-onclick="h7"` (and friends) on every
   element with handlers. Hydration later strips them, but crawlers/devs still
   see polluted markup.
2. **Two-phase hydration** – Clients must scan each element, parse/remove
   attributes, and rebuild handler maps before delegation works.
3. **Refs rely on attributes** – `data-live-ref` is the only bridge between a
   ref ID and its DOM node, so refs cannot exist without metadata in the HTML.
4. **Debug opacity** – Once attributes are removed the DOM carries no hint of
   handler bindings, making inspection harder (and we can’t re-add them without
   undoing clean HTML).

## 2. Design Goals

- Server HTML is byte-for-byte what developers describe with `h.*` builders.
- Handler/Router/Ref metadata ships alongside HTML in boot/init frames and in
  subsequent diffs.
- Slot IDs, component paths, and list metadata already generated by the
  structured renderer remain the canonical addressing scheme.
- Event delegation stays centralized; only the way we hydrate handler bindings
  changes.

## 3. Metadata Layout

### 3.1 Boot / Init Payload

```jsonc
{
  "html": "<div><button>-</button><span>0</span><button>+</button></div>",
  "handlers": {
    "slots": {
      "4": [
        { "event": "click", "handler": "h7", "listen": ["pointerdown"], "props": ["target.value"] }
      ]
    },
    "statics": [
      { "componentId": "root", "path": [3], "bindings": [{ "event": "click", "handler": "h8" }] }
    ]
  },
  "refs": [
    { "id": "ref:2", "componentId": "root", "path": [2, 0], "events": { "change": { "props": ["target.files"] } } }
  ],
  "componentPaths": [...],
  "slotPaths": [...],
  "listPaths": [...]
}
```

- **`handlers.slots`** – keyed by slot ID (already stable for dynamic attrs).
  Each entry mirrors today’s `protocol.SlotBinding`.
- **`handlers.statics`** – rare fallback for elements that never became
  dynamic slots. Uses `{componentId, path}` addressing (path = child indices
  inside the component root).
- **`refs`** – maps ref IDs to component-relative paths plus optional ref-level
  event metadata (for `ref.AddListener` selectors).

### 3.2 Frame Deltas

- Keep `handlers.add` / `handlers.del` (the handler registry map).
- Add optional `bindings` section:
  ```jsonc
  "bindings": {
    "slots": { "9": [...] },
    "statics": [{ "componentId": "root", "path": [1], "bindings": [...] }]
  }
  ```
- `refs` delta already exists; swap attribute-based addressing for component
  paths.

## 4. Hydration Flow

### 4.1 Client Boot
1. Render HTML exactly as received.
2. Use existing manifest utilities to resolve `componentPaths` and `slotPaths`
   back to DOM nodes (already performed today during router boots).
3. Populate:
   - `handlerBindings: WeakMap<Element, Map<event, handlerId>>`
   - `routerMeta: WeakMap<Element, RouterMeta>`
   - `refRegistry: Map<refId, Element>`
4. Delegate events using only the WeakMaps—no DOM attribute reads/removals.

### 4.2 Patches
- When a slot updates, the diff already carries new HTML and slot IDs; we apply
  DOM ops then call `applyBindings(node, specs)` using the metadata in the
  frame.
- Component boots include `bindings` just like boot/init.
- Ref deltas update the registry map without touching HTML.

### 4.3 Error Recovery
- If resolving a slot/component path fails, log in dev mode and request a
  component reboot (the same path router uses today when hydration fails).
- Because addressing is component-scoped, issues stay localized.

## 5. Server Changes

1. **Rendering** – Stop writing `data-on*`, `data-router-*`, `data-live-ref`.
   Instead persist handler/ref metadata directly in `render.Structured`.
2. **Metadata Extraction** – Extend `extractHandlerMeta` to emit two buckets
   (`slots`, `statics`). Reuse `SlotPaths`, `ComponentPaths`, and `elementPath`
   data we already compute.
3. **Protocol** – Update boot/init/frame payload schemas to include the new
   `bindings` structure (and adapt `protocol.BindingTable` usage).
4. **Compatibility** – Gate behind a feature flag so old clients keep stripping
   attributes until the new path is stable.

## 6. Client Changes

1. Remove `primeHandlerBindings`/`refreshHandlerBindings` attribute parsing.
2. Extend manifest resolver helpers to return DOM nodes for `(componentId,
   path)` lookups (most of this logic already exists for router boots).
3. Replace the attribute-based router metadata cache with data from the new
   payload (e.g., `bindings.router` or part of `bindings.statics`).
4. Update event delegation (`handleEvent`) to consult only the WeakMap /
   handler registry; fallback scanning goes away.
5. Adjust ref utilities to use the metadata-fed registry instead of querying
   `[data-live-ref="id"]`.

## 7. Open Questions

| Topic | Notes |
| --- | --- |
| Slot ID Stability | Slot IDs remain stable within a component’s lifetime; replaced only when the component rerenders with different structure. |
| Static bindings prevalence | Expected to be rare since any handler currently forces a DynAttrs slot. Keep support for completeness, but instrument to measure frequency. |
| Ref listeners | Refs still merge their listeners into element handlers during attachment; metadata simply states which refs exist and what selectors they need. |
| Perf | WeakMap lookups should be cheaper than attribute reads; we’ll benchmark once implemented, but both are O(1). |
| Recovery | Missing slot/component path → log + request component reboot/reconnect, same strategy we use for hydration failures today. |

## 8. Migration Plan

1. Add dual-render mode: server emits both attributes and metadata; client uses
   metadata when `feature.cleanHandlers` is enabled.
2. Instrument to ensure slot/static mappings resolve 100% under real apps.
3. Remove attribute emission + legacy client path once telemetry looks good.

With this plan, “clean HTML” becomes a hard guarantee while keeping the existing
diff/render pipeline intact. Handlers, router metadata, and refs move entirely
into structured payloads, eliminating the scan/strip phase on the client and
aligning with the structured DOM goals already documented in `docs/structured-dom.md`.
