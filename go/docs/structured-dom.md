# Structured Rendering DOM

This document defines the _new_ structured rendering contract between PondLive
servers and clients. The intent is to guarantee that:

1. The HTML developers author in Go is byte-for-byte identical to what lands in
   the browser. No hidden spans, wrappers, or comment sentinels are introduced.
2. The runtime still knows how to hydrate refs, register handlers, and replace
   routed subtrees—using metadata that mirrors the DOM instead of modifying it.

The rest of the document walks through an end-to-end example and then drills
into the responsibilities of the server, router, and client.

## 1. Example Walkthrough

### 1.1 Developer-authored component

```go
func RefsTestPage(ctx live.Ctx, props struct{}) h.Node {
    return h.Fragment(
        DivRefSection(ctx),
        ButtonRefSection(ctx),
        InputRefSection(ctx),
        MultiHandlerSection(ctx),
    )
}
```

Key constraint: a developer reading _view-source_ should see exactly the same
markup they described. A fragment merely groups nodes; it does not introduce a
wrapper element.

### 1.2 HTML emitted by SSR

```
<div data-ref="div-section">…</div>
<section data-ref="button-section">…</section>
<section data-ref="input-section">…</section>
<section data-ref="multi-handler">…</section>
```

Fragments simply concatenate their children, so the HTML is four sibling root
nodes. There are no comment placeholders or anonymous spans.

### 1.3 Structured metadata emitted alongside HTML

During SSR, `component_session.RenderNode` produces a `render.Structured`
payload that accompanies the HTML inside the boot frame:

```jsonc
{
  "componentId": "ca74f1e27eecaa5c6b30fd735",
  "componentPaths": [
    { "componentId": "ca74f1e27eecaa5c6b30fd735", "path": [], "range": [0, 4] },
    { "componentId": "cb950d50589bb1d6938a738ac", "path": [1], "range": [0, 1] }
  ],
  "slotPaths": [
    { "slot": 0, "componentId": "ca74f1e27eecaa5c6b30fd735", "elementPath": [0] },
    { "slot": 1, "componentId": "ca74f1e27eecaa5c6b30fd735", "elementPath": [1] },
    { "slot": 2, "componentId": "ca74f1e27eecaa5c6b30fd735", "elementPath": [2] },
    { "slot": 3, "componentId": "ca74f1e27eecaa5c6b30fd735", "elementPath": [3] }
  ],
  "listPaths": [],
  "fragments": [
    { "fragmentId": "frag:0", "childIndexes": [0, 1, 2, 3] }
  ]
}
```

- `componentPaths` describe where each component subtree starts/ends relative
  to the parent DOM node. Ranges are expressed as comment-free child index
  spans.
- `slotPaths` map slot numbers (refs/events) to concrete element paths—these
  paths ignore fragment boundaries because fragments never generate DOM.
- `fragments` record fragment boundaries purely for diagnostics/debugging. The
  runtime never turns them into nodes.

### 1.4 Client hydration

When the browser receives the boot frame, LiveUI performs:

1. **Apply component ranges**: rebuild the map
   `componentId -> { container, startIndex, endIndex }` using the DOM tree and
   the provided `componentPaths`.
2. **Resolve slot anchors**: walk each `elementPath`, locate the actual DOM
   node, and register it inside `dom.registerSlot(slotId, node)`.
3. **Attach handlers/refs**: now that every slot maps to a concrete element,
   refs (`ref:0`) and events have a live node to bind to.

This same procedure runs for `componentBoot` effects generated by router
navigations or async component mounts, so client-side routing never needs
template resets.

## 2. Server Responsibilities

1. **Emit exact HTML**. Fragments should _only_ flatten their children; there
   must never be server-side wrappers whose sole purpose is bookkeeping.
2. **Produce deterministic structured metadata**. Every render pass must emit
   `componentPaths`, `slotPaths`, and `listPaths` that reflect the actual DOM
   indices after fragments are flattened.
3. **Router diffs, not resets**. Navigations should send incremental deltas and
   componentBoot effects for new routes instead of forcing `requestTemplateReset`.
4. **Keep fragments virtual**. The structured payload tracks fragment
   boundaries so developers can reason about them, but the DOM stays clean.

## 3. Router & Fragment Strategy

- Each route is a regular component. When navigation occurs, the router
  requests a diff from the runtime and ships the resulting `componentBoot`
  effects. Those effects already contain the metadata described above, so
  hydration is identical to initial boot.
- Because fragments are flattened, replacing one route with another simply
  means replacing a range (`[startIndex,endIndex)`) in the DOM. No synthetic
  anchors are necessary.
- Streams or other hooks **must not** trigger template resets. If a stream
  changes length, it should emit a `listPaths` update that reindexes the range
  but keeps existing slots stable.

## 4. Client Responsibilities

1. **Trust the metadata**. Instead of trying to infer structure from the DOM,
   always reapply `componentPaths` and `slotPaths` whenever a boot/componentBoot
   effect arrives.
2. **Validate anchors aggressively**. If a slot path fails to resolve, the
   client should log the mismatch (as it does today) because it indicates a bug
   in the structured data. These warnings should become fatal under debug flags
   so router regressions are caught immediately.
3. **No wrapper insertion**. The client must never “fix” missing nodes by
   inserting extra DOM—doing so would violate the parity contract.

### 4.4 Template Caching (Optional)

- Template payloads include a `templateHash` (e.g., hash of statics/dynamics) so
  clients can reuse cached DOM for repeated templates.
- Client maintains a cache keyed by `(componentId, templateHash)` storing:
  - The `DocumentFragment` built from statics (`S`) (clonable).
  - The `S`/`D` arrays and binding blueprints (paths, slot/list registries).
- On subsequent payloads with the same hash, the client clones the cached
  fragment and reapplies dynamic slots/bindings instead of re-parsing HTML.
- Cache eviction can use LRU (keep N entries or total size). Updating the hash
  automatically invalidates old entries.

## 5. Summary

- Structured metadata replaces DOM wrappers/comments as the way we keep track
  of refs, slots, and component ranges.
- Fragments are purely compile-time constructs that flatten into their child
  nodes; their only runtime footprint is the metadata describing where their
  children ended up.
- Router navigations share the same boot/componentBoot pipeline as initial SSR,
  so `/refs` and every other route hydrate identically.

With this contract in place, we can rework the router and client code without
ad-hoc patches: the HTML stays pristine, and the runtime still has all the
information it needs to hydrate complex trees—including fragment-heavy ones.
