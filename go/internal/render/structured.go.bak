// Package rerender transforms a component tree into a structured template
// that separates static HTML from dynamic slots.
//
// Path Navigation Model:
//   - PathRangeOffset: Navigate within a component's child range by skipping
//     non-whitespace children. Example: PathSegment{PathRangeOffset, 2} means
//     skip 2 DOM-visible children within the component's range.
//   - PathDomChild: Navigate to a specific DOM child by index in childNodes.
//     Example: PathSegment{PathDomChild, 1} means the second child in the
//     parent's childNodes array.
//
// Whitespace Handling:
//   - The domWidth() function returns 0 for whitespace-only text nodes,
//     ensuring server-side path calculation aligns with client-side DOM pruning.
//   - Mutable text nodes always count (even if whitespace-only) since they
//     represent dynamic content slots.
//
// Path Composition:
//   - Valid paths must start with PathRangeOffset (component boundary)
//   - PathDomChild segments can follow PathRangeOffset or other PathDomChild
//   - PathRangeOffset cannot follow PathDomChild (invalid navigation)
package rerender

import (
	"html"
	"sort"
	"strings"

	"github.com/eleven-am/pondlive/go/internal/dom"
	"github.com/eleven-am/pondlive/go/internal/handlers"
	h "github.com/eleven-am/pondlive/go/pkg/live/html"
)

var _ NodeVisitor = (*structuredBuilder)(nil)

func ToStructured(n h.Node) (Structured, error) {
	return ToStructuredWithHandlers(n, StructuredOptions{})
}

func ToStructuredWithHandlers(n h.Node, opts StructuredOptions) (Structured, error) {
	if n == nil {
		return Structured{}, &ValidationError{Message: "root node cannot be nil"}
	}

	validator := NewTreeValidator()
	if err := validator.Validate(n); err != nil {
		return Structured{}, err
	}

	FinalizeWithHandlers(n, opts.Handlers)

	analyzer := NewComponentAnalyzer()
	analysis := analyzer.Analyze(n)

	builder := &structuredBuilder{
		tracker:    opts.Promotions,
		bindings:   NewBindingExtractor(),
		pathCalc:   NewPathCalculator(),
		statics:    make([]string, 0, analysis.StaticsCapacity),
		dynamics:   make([]DynamicSlot, 0, analysis.DynamicsCapacity),
		components: analysis.Components,
	}
	builder.visit(n)
	builder.flush()
	return Structured{
		S:              builder.statics,
		D:              builder.dynamics,
		Components:     builder.components,
		Bindings:       builder.bindings.HandlerBindings(),
		UploadBindings: builder.bindings.UploadBindings(),
		RefBindings:    builder.bindings.RefBindings(),
		RouterBindings: builder.bindings.RouterBindings(),
		SlotPaths:      builder.bindings.SlotPaths(),
		ListPaths:      builder.pathCalc.ListPaths(),
		ComponentPaths: builder.pathCalc.ComponentPaths(),
	}, nil
}

func (b *structuredBuilder) writeStatic(s string) {
	if s == "" {
		return
	}
	b.current.WriteString(s)
}

func (b *structuredBuilder) flush() {
	b.statics = append(b.statics, b.current.String())
	b.current.Reset()
}

func (b *structuredBuilder) addDyn(d DynamicSlot) int {
	b.flush()
	b.dynamics = append(b.dynamics, d)
	return len(b.dynamics) - 1
}

func (b *structuredBuilder) visit(n h.Node) int {
	switch v := n.(type) {
	case *h.TextNode:
		return b.VisitText(v)
	case *h.Element:
		return b.VisitElement(v)
	case *h.FragmentNode:
		return b.VisitFragment(v)
	case *h.CommentNode:
		return b.VisitComment(v)
	case *h.ComponentNode:
		return b.VisitComponent(v)
	default:
		return 0
	}
}

func (b *structuredBuilder) VisitText(t *h.TextNode) int {
	if t == nil {
		return 0
	}
	dynamic := t.Mutable
	if !dynamic && b.tracker != nil {
		componentID := b.pathCalc.CurrentComponentID()
		path := b.currentComponentPath()
		dynamic = b.tracker.ResolveTextPromotion(componentID, path, t.Value, t.Mutable)
	}
	if dynamic {
		idx := b.addDyn(DynamicSlot{Kind: DynamicText, Text: t.Value})
		b.appendSlotToCurrent(idx, t)
		return 1
	}
	b.writeStatic(html.EscapeString(t.Value))
	return 1
}

func (b *structuredBuilder) VisitComment(c *h.CommentNode) int {
	if c == nil {
		return 0
	}
	b.writeStatic("<!--")
	b.writeStatic(escapeComment(c.Value))
	b.writeStatic("-->")
	return 1
}

func (b *structuredBuilder) VisitComponent(v *h.ComponentNode) int {
	if v == nil || v.ID == "" {
		if v != nil && v.Child != nil {
			return b.visit(v.Child)
		}
		return 0
	}
	b.flush()
	staticsStart := len(b.statics)
	dynamicsStart := len(b.dynamics)
	b.pathCalc.PushComponent(v.ID)
	width := 0
	if v.Child != nil {
		width = b.visit(v.Child)
	}
	b.pathCalc.PopComponent()
	b.flush()
	span := ComponentSpan{
		StaticsStart:  staticsStart,
		StaticsEnd:    len(b.statics),
		DynamicsStart: dynamicsStart,
		DynamicsEnd:   len(b.dynamics),
	}
	if b.components == nil {
		b.components = make(map[string]ComponentSpan)
	}
	b.components[v.ID] = span
	return width
}

func (b *structuredBuilder) VisitElement(v *h.Element) int {
	if v == nil {
		return 0
	}

	void, attrSlot, startStatic := b.renderOpeningTag(v)
	b.pushFrame(v, attrSlot, startStatic, void, attrSlot < 0)
	defer b.popFrame()

	if void {
		return 1
	}

	b.processElementChildren(v, attrSlot)
	b.renderClosingTag(v)
	return 1
}

func (b *structuredBuilder) renderOpeningTag(v *h.Element) (void bool, attrSlot int, startStatic int) {
	void = dom.IsVoidElement(v.Tag)
	dynamicAttrs := b.shouldUseDynamicAttrs(v)
	attrSlot = -1
	startStatic = -1

	if dynamicAttrs {
		b.writeStatic("<")
		b.writeStatic(v.Tag)
		attrs := copyAttrs(v.Attrs)
		if attrs == nil {
			attrs = map[string]string{}
		}
		attrSlot = b.addDyn(DynamicSlot{Kind: DynamicAttrs, Attrs: attrs})
		startStatic = len(b.statics) - 1
		if void {
			b.writeStatic("/>")
		} else {
			b.writeStatic(">")
		}
	} else {
		start := renderStartTag(v, void)
		b.writeStatic(start)
		b.flush()
		startStatic = len(b.statics) - 1
	}

	return void, attrSlot, startStatic
}

func (b *structuredBuilder) processElementChildren(v *h.Element, attrSlot int) {
	if v.Unsafe != nil {
		b.writeStatic(*v.Unsafe)
	} else if !b.tryKeyedChildren(v.Children) {
		b.visitChildren(v.Children)
	}
}

func (b *structuredBuilder) renderClosingTag(v *h.Element) {
	b.writeStatic("</")
	b.writeStatic(v.Tag)
	b.writeStatic(">")
}

func (b *structuredBuilder) VisitFragment(f *h.FragmentNode) int {
	if f == nil {
		return 0
	}
	if b.tryKeyedChildren(f.Children) {
		return 0
	}
	return b.visitChildren(f.Children)
}

func (b *structuredBuilder) shouldUseDynamicAttrs(el *h.Element) bool {
	if el == nil {
		return false
	}
	if len(el.HandlerAssignments) > 0 {
		return true
	}
	for name, value := range el.Attrs {
		if value == "" {
			continue
		}
		if isDynamicAttr(name) {
			return true
		}
	}
	mutable := el.MutableAttrs
	if tracker := b.tracker; tracker != nil {
		componentID := b.pathCalc.CurrentComponentID()
		path := b.currentComponentPath()
		if tracker.ResolveAttrPromotion(componentID, path, el.Attrs, mutable) {
			return true
		}
	}
	return shouldForceDynamicAttrs(mutable, el.Attrs)
}

func isDynamicAttr(name string) bool {
	if strings.HasPrefix(name, "data-on") {
		return true
	}
	switch name {
	case "value", "checked", "selected":
		return true
	default:
		return false
	}
}

func shouldForceDynamicAttrs(mutable map[string]bool, attrs map[string]string) bool {
	if len(mutable) == 0 {
		return false
	}
	if mutable["*"] {
		return true
	}
	if len(attrs) == 0 {
		return false
	}
	for key := range attrs {
		if mutable[key] {
			return true
		}
	}
	return false
}

func (b *structuredBuilder) pushFrame(el *h.Element, attrSlot, startStatic int, void, staticAttrs bool) {
	frame := elementFrame{
		attrSlot:      attrSlot,
		element:       el,
		startStatic:   startStatic,
		void:          void,
		staticAttrs:   staticAttrs,
		componentID:   b.pathCalc.CurrentComponentID(),
		componentPath: b.currentComponentPath(),
		basePath:      b.currentComponentBasePath(),
	}
	if attrSlot >= 0 {
		frame.bindings = append(frame.bindings, slotBinding{slot: attrSlot, childIndex: -1})
	}
	b.stack = append(b.stack, frame)
}

func (b *structuredBuilder) appendSlotToCurrent(slot int, node h.Node) {
	if len(b.stack) == 0 {
		return
	}
	frame := &b.stack[len(b.stack)-1]
	binding := slotBinding{slot: slot, childIndex: -1}
	if txt, ok := node.(*h.TextNode); ok {
		binding.childIndex = childIndexOf(frame.element, txt)
	}
	frame.bindings = append(frame.bindings, binding)
}

func (b *structuredBuilder) pushChildIndex(idx int) {
	if len(b.componentStack) == 0 {
		return
	}
	b.componentPath = append(b.componentPath, idx)
	b.recordComponentTraversal()
}

func (b *structuredBuilder) popChildIndex() {
	if len(b.componentStack) == 0 {
		return
	}
	if len(b.componentPath) > 0 {
		b.componentPath = b.componentPath[:len(b.componentPath)-1]
	}
}


func (b *structuredBuilder) popFrame() {
	if len(b.stack) == 0 {
		return
	}
	last := len(b.stack) - 1
	frame := b.stack[last]
	b.stack = b.stack[:last]
	b.assignSlotIndices(frame)
}

func (b *structuredBuilder) assignSlotIndices(frame elementFrame) {
	if frame.staticAttrs && frame.startStatic >= 0 && frame.startStatic < len(b.statics) {
		b.statics[frame.startStatic] = renderStartTag(frame.element, frame.void)
	}

	b.bindings.ExtractAll(frame)
}

func escapeComment(value string) string {
	return strings.ReplaceAll(value, "--", "- -")
}

func childIndexOf(parent *h.Element, target h.Node) int {
	if parent == nil || target == nil {
		return -1
	}
	for idx, child := range parent.Children {
		if child == target {
			return idx
		}
	}
	return -1
}

func (b *structuredBuilder) visitChildren(children []h.Node) int {
	return b.visitChildrenWithOffset(children, 0)
}

func (b *structuredBuilder) visitChildrenWithOffset(children []h.Node, start int) int {
	offset := start
	for _, child := range children {
		offset += b.visitChildNode(child, offset)
	}
	return offset - start
}

func (b *structuredBuilder) visitChildNode(child h.Node, domIndex int) int {
	switch v := child.(type) {
	case nil:
		return 0
	case *h.FragmentNode:
		consumed := 0
		offset := domIndex
		for _, inner := range v.Children {
			width := b.visitChildNode(inner, offset)
			offset += width
			consumed += width
		}
		return consumed
	default:
		width := domWidth(child)
		if width == 0 {
			b.visit(child)
			return 0
		}
		b.pushChildIndex(domIndex)
		w := b.visit(child)
		b.popChildIndex()
		if w <= 0 {
			return width
		}
		return width
	}
}

func domWidth(n h.Node) int {
	switch v := n.(type) {
	case *h.Element:
		return 1
	case *h.CommentNode:
		return 1
	case *h.TextNode:
		if strings.TrimSpace(v.Value) == "" && !v.Mutable {
			return 0
		}
		return 1
	case *h.FragmentNode:
		total := 0
		for _, child := range v.Children {
			total += domWidth(child)
		}
		return total
	case *h.ComponentNode:
		if v.Child == nil {
			return 0
		}
		return domWidth(v.Child)
	default:
		return 0
	}
}

func copyAttrs(attrs map[string]string) map[string]string {
	if len(attrs) == 0 {
		return nil
	}
	out := make(map[string]string, len(attrs))
	for k, v := range attrs {
		out[k] = v
	}
	return out
}

func renderStartTag(el *h.Element, void bool) string {
	if el == nil {
		return ""
	}
	var b strings.Builder
	b.WriteByte('<')
	b.WriteString(el.Tag)
	if len(el.Attrs) > 0 {
		keys := make([]string, 0, len(el.Attrs))
		for k := range el.Attrs {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			if strings.HasPrefix(k, "data-on") {
				continue
			}
			v := el.Attrs[k]
			if v == "" {
				continue
			}
			b.WriteByte(' ')
			b.WriteString(k)
			b.WriteString("=\"")
			b.WriteString(html.EscapeString(v))
			b.WriteString("\"")
		}
	}
	if void {
		b.WriteByte('>')
		return b.String()
	}
	b.WriteByte('>')
	return b.String()
}

func renderFinalizedNode(n h.Node) string {
	if n == nil {
		return ""
	}
	var b strings.Builder
	renderNode(&b, n)
	return b.String()
}

func renderNode(b *strings.Builder, n h.Node) {
	switch v := n.(type) {
	case *h.TextNode:
		b.WriteString(html.EscapeString(v.Value))
	case *h.Element:
		renderElement(b, v)
	case *h.FragmentNode:
		for _, child := range v.Children {
			if child != nil {
				renderNode(b, child)
			}
		}
	case *h.CommentNode:
		b.WriteString("<!--")
		b.WriteString(strings.ReplaceAll(v.Value, "--", "- -"))
		b.WriteString("-->")
	case *h.ComponentNode:
		if v.Child != nil {
			renderNode(b, v.Child)
		}
	}
}

func renderElement(b *strings.Builder, e *h.Element) {
	if e == nil {
		return
	}
	b.WriteByte('<')
	b.WriteString(e.Tag)
	if len(e.Attrs) > 0 {
		keys := make([]string, 0, len(e.Attrs))
		for k := range e.Attrs {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for _, k := range keys {
			if strings.HasPrefix(k, "data-on") {
				continue
			}
			v := e.Attrs[k]
			if v == "" {
				continue
			}
			b.WriteByte(' ')
			b.WriteString(k)
			b.WriteString("=\"")
			b.WriteString(html.EscapeString(v))
			b.WriteString("\"")
		}
	}
	if dom.IsVoidElement(e.Tag) {
		b.WriteByte('>')
		return
	}
	b.WriteByte('>')
	if e.Unsafe != nil {
		b.WriteString(*e.Unsafe)
	} else {
		for _, child := range e.Children {
			if child != nil {
				renderNode(b, child)
			}
		}
	}
	b.WriteString("</")
	b.WriteString(e.Tag)
	b.WriteByte('>')
}

func collectKeyedNodes(children []h.Node) []h.Node {
	rows := make([]h.Node, 0, len(children))
	for _, child := range children {
		if child == nil {
			continue
		}
		if nodeKey(child) == "" {
			return nil
		}
		rows = append(rows, child)
	}
	if len(rows) == 0 {
		return nil
	}
	return rows
}

func nodeKey(node h.Node) string {
	switch v := node.(type) {
	case *h.Element:
		return v.Key
	case *h.ComponentNode:
		return v.Key
	default:
		return ""
	}
}

func countTopLevelNodes(node h.Node) int {
	switch v := node.(type) {
	case *h.FragmentNode:
		total := 0
		for _, child := range v.Children {
			total += countTopLevelNodes(child)
		}
		return total
	case *h.ComponentNode:
		if v.Child == nil {
			return 0
		}
		return countTopLevelNodes(v.Child)
	case nil:
		return 0
	default:
		return 1
	}
}

func (b *structuredBuilder) tryKeyedChildren(children []h.Node) bool {
	rows := collectKeyedNodes(children)
	if len(rows) == 0 {
		return false
	}

	listSlot := b.addDyn(DynamicSlot{Kind: DynamicList})
	rowEntries := b.processKeyedRows(rows)

	if listSlot >= 0 && listSlot < len(b.dynamics) {
		b.dynamics[listSlot].List = rowEntries
	}

	b.recordListPath(listSlot)
	return true
}

func (b *structuredBuilder) processKeyedRows(rows []h.Node) []Row {
	rowEntries := make([]Row, 0, len(rows))
	domOffset := 0

	for _, row := range rows {
		if row == nil {
			continue
		}

		rowKey := nodeKey(row)
		snapshot := b.captureBuilderState()
		width := b.visitChildNode(row, domOffset)
		domOffset += width
		rowData := b.extractRowData(snapshot, row, rowKey)
		rowEntries = append(rowEntries, rowData)
	}

	return rowEntries
}

type builderSnapshot struct {
	dynamicsLen      int
	bindingsLen      int
	slotPathsLen     int
	listPathsLen     int
	componentPathLen int
	uploadLen        int
	refLen           int
	routerLen        int
}

func (b *structuredBuilder) captureBuilderState() builderSnapshot {
	return builderSnapshot{
		dynamicsLen:      len(b.dynamics),
		bindingsLen:      b.bindings.handlerBindingsLen(),
		slotPathsLen:     b.bindings.slotPathsLen(),
		listPathsLen:     len(b.listPaths),
		componentPathLen: len(b.componentPaths),
		uploadLen:        b.bindings.uploadBindingsLen(),
		refLen:           b.bindings.refBindingsLen(),
		routerLen:        b.bindings.routerBindingsLen(),
	}
}

func (b *structuredBuilder) extractRowData(snapshot builderSnapshot, row h.Node, rowKey string) Row {
	endDynamics := len(b.dynamics)
	if endDynamics <= snapshot.dynamicsLen {
		return Row{Key: rowKey}
	}

	slots := make([]int, 0, endDynamics-snapshot.dynamicsLen)
	for i := snapshot.dynamicsLen; i < endDynamics; i++ {
		slots = append(slots, i)
	}

	return Row{
		Key:            rowKey,
		HTML:           renderFinalizedNode(row),
		Slots:          slots,
		Bindings:       b.bindings.extractHandlerBindingsSlice(snapshot.bindingsLen),
		SlotPaths:      b.bindings.extractSlotPathsSlice(snapshot.slotPathsLen),
		ListPaths:      extractSlice(b.listPaths, snapshot.listPathsLen),
		ComponentPaths: extractSlice(b.componentPaths, snapshot.componentPathLen),
		UploadBindings: b.bindings.extractUploadBindingsSlice(snapshot.uploadLen),
		RefBindings:    b.bindings.extractRefBindingsSlice(snapshot.refLen),
		RouterBindings: b.bindings.extractRouterBindingsSlice(snapshot.routerLen),
		RootCount:      countTopLevelNodes(row),
	}
}

func extractSlice[T any](slice []T, startIdx int) []T {
	endIdx := len(slice)
	if endIdx <= startIdx {
		return nil
	}
	return append([]T(nil), slice[startIdx:endIdx]...)
}

func (b *structuredBuilder) recordListPath(listSlot int) {
	if len(b.stack) > 0 {
		frame := b.stack[len(b.stack)-1]
		if frame.componentID != "" {
			b.listPaths = append(b.listPaths, ListPath{
				Slot:        listSlot,
				ComponentID: frame.componentID,
				Path:        combineTypedPath(frame.basePath, frame.componentPath),
			})
			return
		}
	}

	if componentID := b.pathCalc.CurrentComponentID(); componentID != "" {
		b.listPaths = append(b.listPaths, ListPath{
			Slot:        listSlot,
			ComponentID: componentID,
			AtRoot:      true,
		})
	}
}

// Finalization helpers â€“ minimal versions scoped to this package.

func FinalizeWithHandlers(n h.Node, reg handlers.Registry) h.Node {
	finalizeNode(n, reg)
	return n
}

func finalizeNode(n h.Node, reg handlers.Registry) {
	switch v := n.(type) {
	case *h.Element:
		finalizeElement(v, reg)
		for _, child := range v.Children {
			if child != nil {
				finalizeNode(child, reg)
			}
		}
	case *h.FragmentNode:
		for _, child := range v.Children {
			if child != nil {
				finalizeNode(child, reg)
			}
		}
	case *h.ComponentNode:
		if v.Child != nil {
			finalizeNode(v.Child, reg)
		}
	}
}

func finalizeElement(e *h.Element, reg handlers.Registry) {
	if e == nil {
		return
	}
	attachHandlers(e, reg)
}

func attachHandlers(e *h.Element, reg handlers.Registry) {
	if e == nil || len(e.Events) == 0 || reg == nil {
		return
	}
	if e.HandlerAssignments == nil {
		e.HandlerAssignments = map[string]dom.EventAssignment{}
	}
	keys := make([]string, 0, len(e.Events))
	for k := range e.Events {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, name := range keys {
		binding := e.Events[name]
		id := reg.Ensure(binding.Handler, binding.Key)
		if id == "" {
			continue
		}
		e.HandlerAssignments[name] = dom.EventAssignment{
			ID:     string(id),
			Listen: append([]string(nil), binding.Listen...),
			Props:  append([]string(nil), binding.Props...),
		}
	}
}
